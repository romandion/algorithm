<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>cds: cds::intrusive::TreiberStack&lt; GC, T, Options &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">cds
   &#160;<span id="projectnumber">1.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecds.html">cds</a></li><li class="navelem"><a class="el" href="namespacecds_1_1intrusive.html">intrusive</a></li><li class="navelem"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html">TreiberStack</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">cds::intrusive::TreiberStack&lt; GC, T, Options &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__cds__intrusive__stack.html">Stacks</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Treiber stack.  
 <a href="classcds_1_1intrusive_1_1_treiber_stack.html#details">More...</a></p>

<p><code>#include &lt;cds/intrusive/treiber_stack.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcds_1_1intrusive_1_1_treiber_stack_1_1rebind.html">rebind</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rebind template arguments.  <a href="structcds_1_1intrusive_1_1_treiber_stack_1_1rebind.html#details">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a90b52f0233d7b6a2bba2b6fa474e0618"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a90b52f0233d7b6a2bba2b6fa474e0618"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#a90b52f0233d7b6a2bba2b6fa474e0618">value_type</a></td></tr>
<tr class="memdesc:a90b52f0233d7b6a2bba2b6fa474e0618"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of value stored in the stack <br/></td></tr>
<tr class="memitem:ad00c0ce058eb87bc3042b54798019eab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad00c0ce058eb87bc3042b54798019eab"></a>
typedef options::hook&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#ad00c0ce058eb87bc3042b54798019eab">hook</a></td></tr>
<tr class="memdesc:ad00c0ce058eb87bc3042b54798019eab"><td class="mdescLeft">&#160;</td><td class="mdescRight">hook type <br/></td></tr>
<tr class="memitem:a77a8860548f0104950a2479c8ac29288"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77a8860548f0104950a2479c8ac29288"></a>
typedef hook::node_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#a77a8860548f0104950a2479c8ac29288">node_type</a></td></tr>
<tr class="memdesc:a77a8860548f0104950a2479c8ac29288"><td class="mdescLeft">&#160;</td><td class="mdescRight">node type <br/></td></tr>
<tr class="memitem:a2f319cec3d954c79450d01a02b4b11be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f319cec3d954c79450d01a02b4b11be"></a>
typedef options::disposer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#a2f319cec3d954c79450d01a02b4b11be">disposer</a></td></tr>
<tr class="memdesc:a2f319cec3d954c79450d01a02b4b11be"><td class="mdescLeft">&#160;</td><td class="mdescRight">disposer used <br/></td></tr>
<tr class="memitem:a4b45bb6699ffe615113c1456f142a247"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b45bb6699ffe615113c1456f142a247"></a>
typedef <a class="el" href="structcds_1_1intrusive_1_1get__node__traits.html">get_node_traits</a><br class="typebreak"/>
&lt; <a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#a90b52f0233d7b6a2bba2b6fa474e0618">value_type</a>, <a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#a77a8860548f0104950a2479c8ac29288">node_type</a>, <a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#ad00c0ce058eb87bc3042b54798019eab">hook</a> &gt;<br class="typebreak"/>
::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#a4b45bb6699ffe615113c1456f142a247">node_traits</a></td></tr>
<tr class="memdesc:a4b45bb6699ffe615113c1456f142a247"><td class="mdescLeft">&#160;</td><td class="mdescRight">node traits <br/></td></tr>
<tr class="memitem:af99b26d9630ecb9ca95e8c2a475b6b9e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af99b26d9630ecb9ca95e8c2a475b6b9e"></a>
typedef <br class="typebreak"/>
<a class="el" href="structcds_1_1intrusive_1_1single__link_1_1get__link__checker.html">single_link::get_link_checker</a><br class="typebreak"/>
&lt; <a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#a77a8860548f0104950a2479c8ac29288">node_type</a>, <br class="typebreak"/>
options::link_checker &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#af99b26d9630ecb9ca95e8c2a475b6b9e">link_checker</a></td></tr>
<tr class="memdesc:af99b26d9630ecb9ca95e8c2a475b6b9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">link checker <br/></td></tr>
<tr class="memitem:a0f7422e1f562d2c9b0f128fcc53fef23"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f7422e1f562d2c9b0f128fcc53fef23"></a>
typedef options::memory_model&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#a0f7422e1f562d2c9b0f128fcc53fef23">memory_model</a></td></tr>
<tr class="memdesc:a0f7422e1f562d2c9b0f128fcc53fef23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory ordering. See <a class="el" href="structcds_1_1opt_1_1memory__model.html" title="[type-option] Option setter for C++ memory model">cds::opt::memory_model</a> option. <br/></td></tr>
<tr class="memitem:a8f646a8ad97efb4cd762d938aaa5fb5f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f646a8ad97efb4cd762d938aaa5fb5f"></a>
typedef options::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#a8f646a8ad97efb4cd762d938aaa5fb5f">item_counter</a></td></tr>
<tr class="memdesc:a8f646a8ad97efb4cd762d938aaa5fb5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counting policy used. <br/></td></tr>
<tr class="memitem:ade6aa089a16807056eca2feb2685518a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade6aa089a16807056eca2feb2685518a"></a>
typedef options::stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#ade6aa089a16807056eca2feb2685518a">stat</a></td></tr>
<tr class="memdesc:ade6aa089a16807056eca2feb2685518a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal statistics policy used. <br/></td></tr>
<tr class="memitem:a8cc67309fe837c83d2c8b85f03f52331"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8cc67309fe837c83d2c8b85f03f52331"></a>
typedef GC&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#a8cc67309fe837c83d2c8b85f03f52331">gc</a></td></tr>
<tr class="memdesc:a8cc67309fe837c83d2c8b85f03f52331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Garbage collector. <br/></td></tr>
<tr class="memitem:a19f22ab260a40e6f7cd814913887dce6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19f22ab260a40e6f7cd814913887dce6"></a>
typedef options::back_off&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#a19f22ab260a40e6f7cd814913887dce6">back_off</a></td></tr>
<tr class="memdesc:a19f22ab260a40e6f7cd814913887dce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">back-off strategy <br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ada952d948a44fe61867c0102a81d69fb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada952d948a44fe61867c0102a81d69fb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#ada952d948a44fe61867c0102a81d69fb">TreiberStack</a> ()</td></tr>
<tr class="memdesc:ada952d948a44fe61867c0102a81d69fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs empty stack. <br/></td></tr>
<tr class="memitem:a44b75ebdde022ee4c65f0203cf80a3a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a44b75ebdde022ee4c65f0203cf80a3a5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#a44b75ebdde022ee4c65f0203cf80a3a5">~TreiberStack</a> ()</td></tr>
<tr class="memdesc:a44b75ebdde022ee4c65f0203cf80a3a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor calls <a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#a28ca6973f078ed66953b4985b98f7d18">clear</a> member function. <br/></td></tr>
<tr class="memitem:ab6b971694cbc1e53a8602dd1dbc0b858"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#ab6b971694cbc1e53a8602dd1dbc0b858">push</a> (<a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#a90b52f0233d7b6a2bba2b6fa474e0618">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:ab6b971694cbc1e53a8602dd1dbc0b858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push the item <code>val</code> on the stack.  <a href="#ab6b971694cbc1e53a8602dd1dbc0b858"></a><br/></td></tr>
<tr class="memitem:a1c0af71eebdef539fd74dfc28c12fa46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#a90b52f0233d7b6a2bba2b6fa474e0618">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#a1c0af71eebdef539fd74dfc28c12fa46">pop</a> ()</td></tr>
<tr class="memdesc:a1c0af71eebdef539fd74dfc28c12fa46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop an item from the stack.  <a href="#a1c0af71eebdef539fd74dfc28c12fa46"></a><br/></td></tr>
<tr class="memitem:ae563bab9ed70a7906a98ba1d03c5564a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae563bab9ed70a7906a98ba1d03c5564a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#ae563bab9ed70a7906a98ba1d03c5564a">empty</a> () const </td></tr>
<tr class="memdesc:ae563bab9ed70a7906a98ba1d03c5564a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if stack is empty. <br/></td></tr>
<tr class="memitem:a28ca6973f078ed66953b4985b98f7d18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#a28ca6973f078ed66953b4985b98f7d18">clear</a> ()</td></tr>
<tr class="memdesc:a28ca6973f078ed66953b4985b98f7d18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the stack.  <a href="#a28ca6973f078ed66953b4985b98f7d18"></a><br/></td></tr>
<tr class="memitem:aa6dc21d15f0a914bc6f58d88775893ec"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#aa6dc21d15f0a914bc6f58d88775893ec">size</a> () const </td></tr>
<tr class="memdesc:aa6dc21d15f0a914bc6f58d88775893ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns stack's item count.  <a href="#aa6dc21d15f0a914bc6f58d88775893ec"></a><br/></td></tr>
<tr class="memitem:afe4b01ddef856ac95724f17095b54495"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe4b01ddef856ac95724f17095b54495"></a>
<a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#ade6aa089a16807056eca2feb2685518a">stat</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#afe4b01ddef856ac95724f17095b54495">statistics</a> () const </td></tr>
<tr class="memdesc:afe4b01ddef856ac95724f17095b54495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to internal statistics. <br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ab23d07171c613be4c56a0929a64c4ce4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab23d07171c613be4c56a0929a64c4ce4"></a>
node_type::atomic_node_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#ab23d07171c613be4c56a0929a64c4ce4">m_Top</a></td></tr>
<tr class="memdesc:ab23d07171c613be4c56a0929a64c4ce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Top of the stack. <br/></td></tr>
<tr class="memitem:a661405ceea3e3b82c628b0be253282a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a661405ceea3e3b82c628b0be253282a9"></a>
<a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#a8f646a8ad97efb4cd762d938aaa5fb5f">item_counter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#a661405ceea3e3b82c628b0be253282a9">m_ItemCounter</a></td></tr>
<tr class="memdesc:a661405ceea3e3b82c628b0be253282a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counter. <br/></td></tr>
<tr class="memitem:ab15200efbaf6947ac6f724c20c564300"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab15200efbaf6947ac6f724c20c564300"></a>
<a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#ade6aa089a16807056eca2feb2685518a">stat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#ab15200efbaf6947ac6f724c20c564300">m_stat</a></td></tr>
<tr class="memdesc:ab15200efbaf6947ac6f724c20c564300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal statistics. <br/></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename GC, typename T, typename... Options&gt;<br/>
class cds::intrusive::TreiberStack&lt; GC, T, Options &gt;</h3>

<p>Treiber stack. </p>
<p>Intrusive implementation of well-known Treiber's stack algorithm:</p>
<ul>
<li>R. K. Treiber. Systems programming: Coping with parallelism. Technical Report RJ 5118, IBM Almaden Research Center, April 1986.</li>
</ul>
<p>Template arguments:</p>
<ul>
<li><code>GC</code> - garbage collector type: <a class="el" href="classcds_1_1gc_1_1_h_p.html" title="Hazard Pointer garbage collector.">gc::HP</a>, <a class="el" href="classcds_1_1gc_1_1_h_r_c.html" title="Gidenstam&#39;s garbage collector.">gc::HRC</a>, <a class="el" href="classcds_1_1gc_1_1_p_t_b.html" title="Pass-the-Buck garbage collector.">gc::PTB</a></li>
<li><code>T</code> - type to be inserted into the stack</li>
<li><code>Options</code> - options</li>
</ul>
<p><code>Options</code> are:</p>
<ul>
<li><a class="el" href="structcds_1_1intrusive_1_1opt_1_1hook.html" title="Hook option.">opt::hook</a> - hook used. Possible values are: <a class="el" href="structcds_1_1intrusive_1_1single__link_1_1base__hook.html" title="Base hook.">single_link::base_hook</a>, <a class="el" href="structcds_1_1intrusive_1_1single__link_1_1member__hook.html" title="Member hook.">single_link::member_hook</a>, <a class="el" href="structcds_1_1intrusive_1_1single__link_1_1traits__hook.html" title="Traits hook.">single_link::traits_hook</a>. If the option is not specified, <code>single_link::base_hook&lt;&gt;</code> is used. For Gidenstam's <a class="el" href="classcds_1_1gc_1_1_h_r_c.html" title="Gidenstam&#39;s garbage collector.">gc::HRC</a>, only <a class="el" href="structcds_1_1intrusive_1_1single__link_1_1base__hook.html" title="Base hook.">single_link::base_hook</a> is supported.</li>
<li><a class="el" href="structcds_1_1opt_1_1back__off.html" title="[type-option] Back-off strategy option setter">opt::back_off</a> - back-off strategy used. If the option is not specified, the <a class="el" href="structcds_1_1backoff_1_1empty.html" title="Empty backoff strategy. Do nothing.">cds::backoff::empty</a> is used.</li>
<li><a class="el" href="structcds_1_1intrusive_1_1opt_1_1disposer.html" title="Item disposer option setter.">opt::disposer</a> - the functor used for dispose removed items. Default is <a class="el" href="structcds_1_1intrusive_1_1opt_1_1v_1_1empty__disposer.html" title="Empty item disposer.">opt::v::empty_disposer</a>. This option is used only in <a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#a28ca6973f078ed66953b4985b98f7d18">clear</a> function.</li>
<li><a class="el" href="structcds_1_1intrusive_1_1opt_1_1link__checker.html" title="Link checking.">opt::link_checker</a> - the type of node's link fields checking. Default is <a class="el" href="namespacecds_1_1intrusive_1_1opt.html#a106b4114c23f57e01b00e8bdeca3e5b3a97917de795ef08c17c8f29826c8c2d38">opt::debug_check_link</a>. Note: for <a class="el" href="classcds_1_1gc_1_1_h_r_c.html" title="Gidenstam&#39;s garbage collector.">gc::HRC</a> garbage collector, link checking policy is always selected as <a class="el" href="namespacecds_1_1intrusive_1_1opt.html#a106b4114c23f57e01b00e8bdeca3e5b3aa22c8e6cc23bacdf4cc254f285d83fbe">opt::always_check_link</a>.</li>
<li><a class="el" href="structcds_1_1opt_1_1memory__model.html" title="[type-option] Option setter for C++ memory model">opt::memory_model</a> - C++ memory ordering model. Can be <a class="el" href="structcds_1_1opt_1_1v_1_1relaxed__ordering.html" title="Relaxed memory ordering model.">opt::v::relaxed_ordering</a> (relaxed memory model, the default) or <a class="el" href="structcds_1_1opt_1_1v_1_1sequential__consistent.html" title="Sequential consistent memory ordering model.">opt::v::sequential_consistent</a> (sequentially consisnent memory model).</li>
<li><a class="el" href="structcds_1_1opt_1_1item__counter.html" title="[type-option] Option setter for item counting">opt::item_counter</a> - the type of item counting feature. Default is <a class="el" href="classcds_1_1atomicity_1_1empty__item__counter.html">atomicity::empty_item_counter</a></li>
<li><a class="el" href="structcds_1_1opt_1_1stat.html" title="[type-option] Generic option setter for statisitcs">opt::stat</a> - the type to gather internal statistics. Possible option value are: <a class="el" href="structcds_1_1intrusive_1_1stack__stat.html">intrusive::stack_stat</a>, <a class="el" href="structcds_1_1intrusive_1_1stack__dummy__stat.html">intrusive::stack_dummy_stat</a>, user-provided class that supports <a class="el" href="structcds_1_1intrusive_1_1stack__stat.html" title="Stack internal statistics. May be used for debugging or profiling.">intrusive::stack_stat</a> interface. Default is <a class="el" href="structcds_1_1intrusive_1_1stack__dummy__stat.html">intrusive::stack_dummy_stat</a>.</li>
</ul>
<p>Garbage collecting schema <code>GC</code> must be consistent with the <a class="el" href="structcds_1_1intrusive_1_1single__link_1_1node.html" title="Container&#39;s node.">single_link::node</a> GC.</p>
<p>Be careful when you want destroy an item popped, see <a class="el" href="namespacecds_1_1intrusive.html#cds_intrusive_item_destroying">Destroying items of intrusive containers</a>.</p>
<dl class="section user"><dt>Examples</dt><dd></dd></dl>
<p>Example of how to use <code><a class="el" href="structcds_1_1intrusive_1_1single__link_1_1base__hook.html" title="Base hook.">single_link::base_hook</a></code>. Your class that objects will be pushed on <a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html" title="Treiber stack.">TreiberStack</a> should be based on <a class="el" href="structcds_1_1intrusive_1_1single__link_1_1node.html" title="Container&#39;s node.">single_link::node</a> class </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/intrusive/stack/treiber_stack.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cds/gc/hp.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>ci = cds::intrusive   ;</div>
<div class="line"><span class="keyword">typedef</span> cds::gc::HP <a class="code" href="classcds_1_1intrusive_1_1_treiber_stack.html#a8cc67309fe837c83d2c8b85f03f52331" title="Garbage collector.">gc</a>     ;</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>myData: <span class="keyword">public</span> ci::single_link::node&lt; gc &gt;</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">} ;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Stack type</span></div>
<div class="line"><span class="keyword">typedef</span> ci::TreiberStack&lt; <a class="code" href="classcds_1_1intrusive_1_1_treiber_stack.html#a8cc67309fe837c83d2c8b85f03f52331" title="Garbage collector.">gc</a>,</div>
<div class="line">    myData,</div>
<div class="line">    ci::opt::hook&lt; ci::single_link::base_hook&lt; gc &gt; &gt;</div>
<div class="line">&gt; stack_t   ;</div>
</div><!-- fragment --><p>Example of how to use base_hook with different tags. </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/intrusive/stack/treiber_stack.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cds/gc/hp.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>ci = cds::intrusive   ;</div>
<div class="line"><span class="keyword">typedef</span> cds::gc::HP <a class="code" href="classcds_1_1intrusive_1_1_treiber_stack.html#a8cc67309fe837c83d2c8b85f03f52331" title="Garbage collector.">gc</a>     ;</div>
<div class="line"></div>
<div class="line"><span class="comment">// It is not necessary to declare complete type for tags</span></div>
<div class="line"><span class="keyword">struct </span>tag1 ;</div>
<div class="line"><span class="keyword">struct </span>tag2 ;</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>myData</div>
<div class="line">    : <span class="keyword">public</span> ci::single_link::node&lt; gc, tag1 &gt;</div>
<div class="line">    , <span class="keyword">public</span> ci::single_link::node&lt; gc, tag2 &gt;</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">} ;</div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> ci::TreiberStack&lt; gc, myData, ci::opt::hook&lt; ci::single_link::base_hook&lt; gc, tag1 &gt; &gt; stack1_t   ;</div>
<div class="line"><span class="keyword">typedef</span> ci::TreiberStack&lt; gc, myData, ci::opt::hook&lt; ci::single_link::base_hook&lt; gc, tag2 &gt; &gt; stack2_t   ;</div>
<div class="line"></div>
<div class="line"><span class="comment">// You may add myData objects in the objects of type stack1_t and stack2_t independently</span></div>
<div class="line"><span class="keywordtype">void</span> foo() {</div>
<div class="line">    stack1_t    s1  ;</div>
<div class="line">    stack2_t    s2  ;</div>
<div class="line"></div>
<div class="line">    myData i1, i2   ;</div>
<div class="line">    s1.push( i1 )   ;</div>
<div class="line">    s2.push( i2 )   ;</div>
<div class="line">    s2.push( i1 )   ;   <span class="comment">// i1 is now contained in s1 and s2.</span></div>
<div class="line"></div>
<div class="line">    myData * p      ;</div>
<div class="line"></div>
<div class="line">    p = s1.pop()    ;   <span class="comment">// pop i1 from s1</span></div>
<div class="line">    p = s1.pop()    ;   <span class="comment">// p == NULL, s1 is empty</span></div>
<div class="line">    p = s2.pop()    ;   <span class="comment">// pop i1 from s2</span></div>
<div class="line">    p = s2.pop()    ;   <span class="comment">// pop i2 from s2</span></div>
<div class="line">    p = s2.pop()    ;   <span class="comment">// p == NULL, s2 is empty</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Example of how to use member_hook. Your class that will be pushed on <a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html" title="Treiber stack.">TreiberStack</a> should have a member of type <a class="el" href="structcds_1_1intrusive_1_1single__link_1_1node.html" title="Container&#39;s node.">single_link::node</a> </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/intrusive/stack/treiber_stack.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cds/gc/hp.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stddef.h&gt;</span>     <span class="comment">// offsetof macro</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>ci = cds::intrusive   ;</div>
<div class="line"><span class="keyword">typedef</span> cds::gc::HP <a class="code" href="classcds_1_1intrusive_1_1_treiber_stack.html#a8cc67309fe837c83d2c8b85f03f52331" title="Garbage collector.">gc</a>     ;</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>myData</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">    ci::single_link::node&lt; gc &gt;      member_hook_    ;</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">} ;</div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> ci::TreiberStack&lt; <a class="code" href="classcds_1_1intrusive_1_1_treiber_stack.html#a8cc67309fe837c83d2c8b85f03f52331" title="Garbage collector.">gc</a>, myData,</div>
<div class="line">    ci::opt::hook&lt;</div>
<div class="line">        ci::single_link::member_hook&lt; offsetof(myData, member_hook_),</div>
<div class="line">        gc</div>
<div class="line">    &gt;</div>
<div class="line">&gt; stack_t   ;</div>
</div><!-- fragment --> </div><h2>Member Function Documentation</h2>
<a class="anchor" id="a28ca6973f078ed66953b4985b98f7d18"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html">cds::intrusive::TreiberStack</a>&lt; GC, T, Options &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the stack. </p>
<p>For each removed item the disposer is called.</p>
<p><b>Caution</b> It is possible that after <code><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#a28ca6973f078ed66953b4985b98f7d18" title="Clear the stack.">clear()</a></code> the <code><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#ae563bab9ed70a7906a98ba1d03c5564a" title="Check if stack is empty.">empty()</a></code> returns <code>false</code> if some other thread pushes an item into the stack during <code>clear</code> works </p>

<p>Reimplemented in <a class="el" href="classcds_1_1container_1_1_treiber_stack.html#a0a0dc446b0b05e794be8ce74843af2d6">cds::container::TreiberStack&lt; GC, T, Options &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a1c0af71eebdef539fd74dfc28c12fa46"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#a90b52f0233d7b6a2bba2b6fa474e0618">value_type</a>* <a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html">cds::intrusive::TreiberStack</a>&lt; GC, T, Options &gt;::pop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop an item from the stack. </p>
<p>If stack is empty, returns <code>NULL</code>. The disposer is <b>not</b> called for popped item. See <a class="el" href="namespacecds_1_1intrusive.html#cds_intrusive_item_destroying">Destroying items of intrusive containers</a>. </p>

</div>
</div>
<a class="anchor" id="ab6b971694cbc1e53a8602dd1dbc0b858"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html">cds::intrusive::TreiberStack</a>&lt; GC, T, Options &gt;::push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#a90b52f0233d7b6a2bba2b6fa474e0618">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push the item <code>val</code> on the stack. </p>
<p>No copying is made since it is intrusive stack. </p>

</div>
</div>
<a class="anchor" id="aa6dc21d15f0a914bc6f58d88775893ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html">cds::intrusive::TreiberStack</a>&lt; GC, T, Options &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns stack's item count. </p>
<p>The value returned depends on <a class="el" href="structcds_1_1opt_1_1item__counter.html" title="[type-option] Option setter for item counting">opt::item_counter</a> option. For <a class="el" href="classcds_1_1atomicity_1_1empty__item__counter.html" title="Empty item counter.">atomicity::empty_item_counter</a>, this function always returns 0.</p>
<p><b>Warning</b>: even if you use real item counter and it returns 0, this fact is not mean that the stack is empty. To check emptyness use <a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#ae563bab9ed70a7906a98ba1d03c5564a">empty()</a> method. </p>

<p>Reimplemented in <a class="el" href="classcds_1_1container_1_1_treiber_stack.html#a9607da710f0a53d20641fcc559977da8">cds::container::TreiberStack&lt; GC, T, Options &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cds/intrusive/treiber_stack.h</li>
</ul>
</div><!-- contents -->
		<hr/>
		<div align="right">
			<b>cds</b> <b>1.2.0</b> 
			Developed by <i>Maxim Khiszinsky aka khizmax</i> 2007 - 2012
			<br/>
			<i>Autogenerated Mon Aug 20 2012 22:32:41 by Doxygen 1.8.1.2</i>
		</div>
	</BODY>
</HTML>
