<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>cds: cds::container::BasketQueue&lt; GC, T, Options &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">cds
   &#160;<span id="projectnumber">1.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecds.html">cds</a></li><li class="navelem"><a class="el" href="namespacecds_1_1container.html">container</a></li><li class="navelem"><a class="el" href="classcds_1_1container_1_1_basket_queue.html">BasketQueue</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a>  </div>
  <div class="headertitle">
<div class="title">cds::container::BasketQueue&lt; GC, T, Options &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__cds__nonintrusive__queue.html">Queues</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Basket lock-free queue (non-intrusive variant)  
 <a href="classcds_1_1container_1_1_basket_queue.html#details">More...</a></p>

<p><code>#include &lt;cds/container/basket_queue.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cds::container::BasketQueue&lt; GC, T, Options &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcds_1_1container_1_1_basket_queue.png" usemap="#cds::container::BasketQueue&lt; GC, T, Options &gt;_map" alt=""/>
  <map id="cds::container::BasketQueue&lt; GC, T, Options &gt;_map" name="cds::container::BasketQueue&lt; GC, T, Options &gt;_map">
<area href="classcds_1_1intrusive_1_1_basket_queue.html" alt="cds::intrusive::BasketQueue&lt; GC, intrusive::basket_queue::node&lt; T &gt;, Options... &gt;" shape="rect" coords="0,0,478,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcds_1_1container_1_1_basket_queue_1_1rebind.html">rebind</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rebind template arguments.  <a href="structcds_1_1container_1_1_basket_queue_1_1rebind.html#details">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:abb4a38d60c1d5021c5ba24a94ab16ad8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb4a38d60c1d5021c5ba24a94ab16ad8"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_basket_queue.html#abb4a38d60c1d5021c5ba24a94ab16ad8">value_type</a></td></tr>
<tr class="memdesc:abb4a38d60c1d5021c5ba24a94ab16ad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value type stored in the queue. <br/></td></tr>
<tr class="memitem:a47549bd21e8fdc8012106302bb05b644"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47549bd21e8fdc8012106302bb05b644"></a>
typedef base_class::gc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_basket_queue.html#a47549bd21e8fdc8012106302bb05b644">gc</a></td></tr>
<tr class="memdesc:a47549bd21e8fdc8012106302bb05b644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Garbage collector used. <br/></td></tr>
<tr class="memitem:a2c4beacc59fb85b5e055197ebd156254"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c4beacc59fb85b5e055197ebd156254"></a>
typedef base_class::back_off&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_basket_queue.html#a2c4beacc59fb85b5e055197ebd156254">back_off</a></td></tr>
<tr class="memdesc:a2c4beacc59fb85b5e055197ebd156254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Back-off strategy used. <br/></td></tr>
<tr class="memitem:adc0e21107305b8eadd516f738216ed71"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc0e21107305b8eadd516f738216ed71"></a>
typedef options::allocator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_basket_queue.html#adc0e21107305b8eadd516f738216ed71">allocator_type</a></td></tr>
<tr class="memdesc:adc0e21107305b8eadd516f738216ed71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator type used for allocate/deallocate the nodes. <br/></td></tr>
<tr class="memitem:aa2aa5c5bdefabae8030855c37c1010e4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2aa5c5bdefabae8030855c37c1010e4"></a>
typedef base_class::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_basket_queue.html#aa2aa5c5bdefabae8030855c37c1010e4">item_counter</a></td></tr>
<tr class="memdesc:aa2aa5c5bdefabae8030855c37c1010e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counting policy used. <br/></td></tr>
<tr class="memitem:aad395cff29217cc1cb8853c04d4c01a4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad395cff29217cc1cb8853c04d4c01a4"></a>
typedef base_class::stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_basket_queue.html#aad395cff29217cc1cb8853c04d4c01a4">stat</a></td></tr>
<tr class="memdesc:aad395cff29217cc1cb8853c04d4c01a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal statistics policy used. <br/></td></tr>
<tr class="memitem:ad99d49933c382759ee35f029e6a839b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad99d49933c382759ee35f029e6a839b1"></a>
typedef base_class::memory_model&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_basket_queue.html#ad99d49933c382759ee35f029e6a839b1">memory_model</a></td></tr>
<tr class="memdesc:ad99d49933c382759ee35f029e6a839b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory ordering. See <a class="el" href="structcds_1_1opt_1_1memory__model.html" title="[type-option] Option setter for C++ memory model">cds::opt::memory_model</a> option. <br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7c9d3ad6edbaa767c0fdaecc92c4d80d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c9d3ad6edbaa767c0fdaecc92c4d80d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_basket_queue.html#a7c9d3ad6edbaa767c0fdaecc92c4d80d">BasketQueue</a> ()</td></tr>
<tr class="memdesc:a7c9d3ad6edbaa767c0fdaecc92c4d80d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes empty queue. <br/></td></tr>
<tr class="memitem:a3a06f8d4638f2b0e32c0d1e5e177cce3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a06f8d4638f2b0e32c0d1e5e177cce3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_basket_queue.html#a3a06f8d4638f2b0e32c0d1e5e177cce3">~BasketQueue</a> ()</td></tr>
<tr class="memdesc:a3a06f8d4638f2b0e32c0d1e5e177cce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor clears the queue. <br/></td></tr>
<tr class="memitem:af88d37dc371935d37e99b0bd9ee0b8af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af88d37dc371935d37e99b0bd9ee0b8af"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_basket_queue.html#af88d37dc371935d37e99b0bd9ee0b8af">size</a> () const </td></tr>
<tr class="memdesc:af88d37dc371935d37e99b0bd9ee0b8af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns queue's item count (see <a class="el" href="classcds_1_1intrusive_1_1_basket_queue.html#afb038030c7736e99f32e1113438b7f4a">intrusive::BasketQueue::size</a> for explanation) <br/></td></tr>
<tr class="memitem:a19d96f43b2d84c90fe3d8a847e900397"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19d96f43b2d84c90fe3d8a847e900397"></a>
const <a class="el" href="classcds_1_1container_1_1_basket_queue.html#aad395cff29217cc1cb8853c04d4c01a4">stat</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_basket_queue.html#a19d96f43b2d84c90fe3d8a847e900397">statistics</a> () const </td></tr>
<tr class="memdesc:a19d96f43b2d84c90fe3d8a847e900397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to internal statistics. <br/></td></tr>
<tr class="memitem:aae3a0ca675ebee5f511fc50b4186350b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_basket_queue.html#aae3a0ca675ebee5f511fc50b4186350b">enqueue</a> (const <a class="el" href="classcds_1_1container_1_1_basket_queue.html#abb4a38d60c1d5021c5ba24a94ab16ad8">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:aae3a0ca675ebee5f511fc50b4186350b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues <code>val</code> value into the queue.  <a href="#aae3a0ca675ebee5f511fc50b4186350b"></a><br/></td></tr>
<tr class="memitem:a6b4244e03e4181e339a7da6181aed4d2"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename Func &gt; </td></tr>
<tr class="memitem:a6b4244e03e4181e339a7da6181aed4d2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_basket_queue.html#a6b4244e03e4181e339a7da6181aed4d2">enqueue</a> (const Type &amp;data, Func f)</td></tr>
<tr class="memdesc:a6b4244e03e4181e339a7da6181aed4d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues <code>data</code> to queue using copy functor.  <a href="#a6b4244e03e4181e339a7da6181aed4d2"></a><br/></td></tr>
<tr class="memitem:aa9a84a790dfe2f76c0d67089d76d1a0a"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename Func &gt; </td></tr>
<tr class="memitem:aa9a84a790dfe2f76c0d67089d76d1a0a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_basket_queue.html#aa9a84a790dfe2f76c0d67089d76d1a0a">dequeue</a> (Type &amp;dest, Func f)</td></tr>
<tr class="memdesc:aa9a84a790dfe2f76c0d67089d76d1a0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dequeues a value using copy functor.  <a href="#aa9a84a790dfe2f76c0d67089d76d1a0a"></a><br/></td></tr>
<tr class="memitem:a1e408a443ce1683f1f65b88a4e0ed5a5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_basket_queue.html#a1e408a443ce1683f1f65b88a4e0ed5a5">dequeue</a> (<a class="el" href="classcds_1_1container_1_1_basket_queue.html#abb4a38d60c1d5021c5ba24a94ab16ad8">value_type</a> &amp;dest)</td></tr>
<tr class="memdesc:a1e408a443ce1683f1f65b88a4e0ed5a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dequeues a value from the queue.  <a href="#a1e408a443ce1683f1f65b88a4e0ed5a5"></a><br/></td></tr>
<tr class="memitem:a985fdf5cfdfd205cb227ca46e3c251f1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a985fdf5cfdfd205cb227ca46e3c251f1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_basket_queue.html#a985fdf5cfdfd205cb227ca46e3c251f1">push</a> (const <a class="el" href="classcds_1_1container_1_1_basket_queue.html#abb4a38d60c1d5021c5ba24a94ab16ad8">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a985fdf5cfdfd205cb227ca46e3c251f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym for <a class="el" href="classcds_1_1container_1_1_basket_queue.html#aae3a0ca675ebee5f511fc50b4186350b">enqueue</a> function. <br/></td></tr>
<tr class="memitem:a4fec7150ec5f17135606ad2119229450"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4fec7150ec5f17135606ad2119229450"></a>
template&lt;typename Type , typename Func &gt; </td></tr>
<tr class="memitem:a4fec7150ec5f17135606ad2119229450"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_basket_queue.html#a4fec7150ec5f17135606ad2119229450">push</a> (const Type &amp;data, Func f)</td></tr>
<tr class="memdesc:a4fec7150ec5f17135606ad2119229450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym for template version of <a class="el" href="classcds_1_1container_1_1_basket_queue.html#aae3a0ca675ebee5f511fc50b4186350b">enqueue</a> function. <br/></td></tr>
<tr class="memitem:a574e7a73539d69f8bdab4f0b5ddc7c9b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a574e7a73539d69f8bdab4f0b5ddc7c9b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_basket_queue.html#a574e7a73539d69f8bdab4f0b5ddc7c9b">pop</a> (<a class="el" href="classcds_1_1container_1_1_basket_queue.html#abb4a38d60c1d5021c5ba24a94ab16ad8">value_type</a> &amp;dest)</td></tr>
<tr class="memdesc:a574e7a73539d69f8bdab4f0b5ddc7c9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym for <a class="el" href="classcds_1_1container_1_1_basket_queue.html#aa9a84a790dfe2f76c0d67089d76d1a0a">dequeue</a> function. <br/></td></tr>
<tr class="memitem:ac07479453a49fad07b5dfc8ca45f556f"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac07479453a49fad07b5dfc8ca45f556f"></a>
template&lt;typename Type , typename Func &gt; </td></tr>
<tr class="memitem:ac07479453a49fad07b5dfc8ca45f556f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_basket_queue.html#ac07479453a49fad07b5dfc8ca45f556f">pop</a> (Type &amp;dest, Func f)</td></tr>
<tr class="memdesc:ac07479453a49fad07b5dfc8ca45f556f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym for template version of <a class="el" href="classcds_1_1container_1_1_basket_queue.html#aa9a84a790dfe2f76c0d67089d76d1a0a">dequeue</a> function. <br/></td></tr>
<tr class="memitem:aad45c8a128556519ed5f16195347b690"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_basket_queue.html#aad45c8a128556519ed5f16195347b690">empty</a> ()</td></tr>
<tr class="memdesc:aad45c8a128556519ed5f16195347b690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the queue is empty.  <a href="#aad45c8a128556519ed5f16195347b690"></a><br/></td></tr>
<tr class="memitem:a5023f241c17fed72cd436ce164d389f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_basket_queue.html#a5023f241c17fed72cd436ce164d389f6">clear</a> ()</td></tr>
<tr class="memdesc:a5023f241c17fed72cd436ce164d389f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the queue.  <a href="#a5023f241c17fed72cd436ce164d389f6"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:ad175ad46a1a478961ea52caf64c9e4dc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad175ad46a1a478961ea52caf64c9e4dc"></a>
typedef options::node_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_basket_queue.html#ad175ad46a1a478961ea52caf64c9e4dc">node_type</a></td></tr>
<tr class="memdesc:ad175ad46a1a478961ea52caf64c9e4dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">queue node type (derived from <a class="el" href="structcds_1_1intrusive_1_1single__link_1_1node.html" title="Container&#39;s node.">intrusive::single_link::node</a>) <br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classcds_1_1intrusive_1_1_basket_queue"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classcds_1_1intrusive_1_1_basket_queue')"><img src="closed.png" alt="-"/>&nbsp;Private Types inherited from <a class="el" href="classcds_1_1intrusive_1_1_basket_queue.html">cds::intrusive::BasketQueue< GC, intrusive::basket_queue::node< T >, Options... ></a></td></tr>
<tr class="memitem:abdd98d36c2edf1b928e482980e66b079 inherit pub_types_classcds_1_1intrusive_1_1_basket_queue"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abdd98d36c2edf1b928e482980e66b079"></a>
typedef <br class="typebreak"/>
<a class="el" href="structcds_1_1intrusive_1_1basket__queue_1_1node.html">intrusive::basket_queue::node</a><br class="typebreak"/>
&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_basket_queue.html#abdd98d36c2edf1b928e482980e66b079">value_type</a></td></tr>
<tr class="memdesc:abdd98d36c2edf1b928e482980e66b079 inherit pub_types_classcds_1_1intrusive_1_1_basket_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of value stored in the queue <br/></td></tr>
<tr class="memitem:a6b6e14d57baab7629fba530ec760d649 inherit pub_types_classcds_1_1intrusive_1_1_basket_queue"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b6e14d57baab7629fba530ec760d649"></a>
typedef options::hook&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_basket_queue.html#a6b6e14d57baab7629fba530ec760d649">hook</a></td></tr>
<tr class="memdesc:a6b6e14d57baab7629fba530ec760d649 inherit pub_types_classcds_1_1intrusive_1_1_basket_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">hook type <br/></td></tr>
<tr class="memitem:ad4d8eb00d1f2c55b7ca436bae308ff1b inherit pub_types_classcds_1_1intrusive_1_1_basket_queue"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4d8eb00d1f2c55b7ca436bae308ff1b"></a>
typedef hook::node_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_basket_queue.html#ad4d8eb00d1f2c55b7ca436bae308ff1b">node_type</a></td></tr>
<tr class="memdesc:ad4d8eb00d1f2c55b7ca436bae308ff1b inherit pub_types_classcds_1_1intrusive_1_1_basket_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">node type <br/></td></tr>
<tr class="memitem:aabc91dbb533c38715761d24bd69629ec inherit pub_types_classcds_1_1intrusive_1_1_basket_queue"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aabc91dbb533c38715761d24bd69629ec"></a>
typedef options::disposer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_basket_queue.html#aabc91dbb533c38715761d24bd69629ec">disposer</a></td></tr>
<tr class="memdesc:aabc91dbb533c38715761d24bd69629ec inherit pub_types_classcds_1_1intrusive_1_1_basket_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">disposer used <br/></td></tr>
<tr class="memitem:aa4101187364b1086187a62f980f4650d inherit pub_types_classcds_1_1intrusive_1_1_basket_queue"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa4101187364b1086187a62f980f4650d"></a>
typedef <a class="el" href="structcds_1_1intrusive_1_1get__node__traits.html">get_node_traits</a><br class="typebreak"/>
&lt; <a class="el" href="classcds_1_1intrusive_1_1_basket_queue.html#abdd98d36c2edf1b928e482980e66b079">value_type</a>, <a class="el" href="classcds_1_1intrusive_1_1_basket_queue.html#ad4d8eb00d1f2c55b7ca436bae308ff1b">node_type</a>, <a class="el" href="classcds_1_1intrusive_1_1_basket_queue.html#a6b6e14d57baab7629fba530ec760d649">hook</a> &gt;<br class="typebreak"/>
::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_basket_queue.html#aa4101187364b1086187a62f980f4650d">node_traits</a></td></tr>
<tr class="memdesc:aa4101187364b1086187a62f980f4650d inherit pub_types_classcds_1_1intrusive_1_1_basket_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">node traits <br/></td></tr>
<tr class="memitem:ab034df84429392ae1ab12ee720459cdf inherit pub_types_classcds_1_1intrusive_1_1_basket_queue"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab034df84429392ae1ab12ee720459cdf"></a>
typedef <br class="typebreak"/>
<a class="el" href="structcds_1_1intrusive_1_1basket__queue_1_1get__link__checker.html">basket_queue::get_link_checker</a><br class="typebreak"/>
&lt; <a class="el" href="classcds_1_1intrusive_1_1_basket_queue.html#ad4d8eb00d1f2c55b7ca436bae308ff1b">node_type</a>, <br class="typebreak"/>
options::link_checker &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_basket_queue.html#ab034df84429392ae1ab12ee720459cdf">link_checker</a></td></tr>
<tr class="memdesc:ab034df84429392ae1ab12ee720459cdf inherit pub_types_classcds_1_1intrusive_1_1_basket_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">link checker <br/></td></tr>
<tr class="memitem:a776a684bde1a2253af49b94fd9820ed8 inherit pub_types_classcds_1_1intrusive_1_1_basket_queue"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a776a684bde1a2253af49b94fd9820ed8"></a>
typedef GC&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_basket_queue.html#a776a684bde1a2253af49b94fd9820ed8">gc</a></td></tr>
<tr class="memdesc:a776a684bde1a2253af49b94fd9820ed8 inherit pub_types_classcds_1_1intrusive_1_1_basket_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Garbage collector. <br/></td></tr>
<tr class="memitem:a15558c24d43da61d73881be649aa4b0a inherit pub_types_classcds_1_1intrusive_1_1_basket_queue"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15558c24d43da61d73881be649aa4b0a"></a>
typedef options::back_off&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_basket_queue.html#a15558c24d43da61d73881be649aa4b0a">back_off</a></td></tr>
<tr class="memdesc:a15558c24d43da61d73881be649aa4b0a inherit pub_types_classcds_1_1intrusive_1_1_basket_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">back-off strategy <br/></td></tr>
<tr class="memitem:a03ea4b10c18bac59a64cf6caf49eb169 inherit pub_types_classcds_1_1intrusive_1_1_basket_queue"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a03ea4b10c18bac59a64cf6caf49eb169"></a>
typedef options::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_basket_queue.html#a03ea4b10c18bac59a64cf6caf49eb169">item_counter</a></td></tr>
<tr class="memdesc:a03ea4b10c18bac59a64cf6caf49eb169 inherit pub_types_classcds_1_1intrusive_1_1_basket_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counting policy used. <br/></td></tr>
<tr class="memitem:a58a71ef0a817457db6788b504afda144 inherit pub_types_classcds_1_1intrusive_1_1_basket_queue"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58a71ef0a817457db6788b504afda144"></a>
typedef options::stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_basket_queue.html#a58a71ef0a817457db6788b504afda144">stat</a></td></tr>
<tr class="memdesc:a58a71ef0a817457db6788b504afda144 inherit pub_types_classcds_1_1intrusive_1_1_basket_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal statistics policy used. <br/></td></tr>
<tr class="memitem:a9e51682518b2d1b246a0c5cb011660c4 inherit pub_types_classcds_1_1intrusive_1_1_basket_queue"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e51682518b2d1b246a0c5cb011660c4"></a>
typedef options::memory_model&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_basket_queue.html#a9e51682518b2d1b246a0c5cb011660c4">memory_model</a></td></tr>
<tr class="memdesc:a9e51682518b2d1b246a0c5cb011660c4 inherit pub_types_classcds_1_1intrusive_1_1_basket_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory ordering. See <a class="el" href="structcds_1_1opt_1_1memory__model.html" title="[type-option] Option setter for C++ memory model">cds::opt::memory_model</a> option. <br/></td></tr>
<tr class="inherit_header pub_methods_classcds_1_1intrusive_1_1_basket_queue"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classcds_1_1intrusive_1_1_basket_queue')"><img src="closed.png" alt="-"/>&nbsp;Private Member Functions inherited from <a class="el" href="classcds_1_1intrusive_1_1_basket_queue.html">cds::intrusive::BasketQueue< GC, intrusive::basket_queue::node< T >, Options... ></a></td></tr>
<tr class="memitem:a24ab1c758067d1644839831048af5f95 inherit pub_methods_classcds_1_1intrusive_1_1_basket_queue"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24ab1c758067d1644839831048af5f95"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_basket_queue.html#a24ab1c758067d1644839831048af5f95">BasketQueue</a> ()</td></tr>
<tr class="memdesc:a24ab1c758067d1644839831048af5f95 inherit pub_methods_classcds_1_1intrusive_1_1_basket_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes empty queue. <br/></td></tr>
<tr class="memitem:a48bfd4b13cf70c88a1df371f53d9ca59 inherit pub_methods_classcds_1_1intrusive_1_1_basket_queue"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_basket_queue.html#a48bfd4b13cf70c88a1df371f53d9ca59">~BasketQueue</a> ()</td></tr>
<tr class="memdesc:a48bfd4b13cf70c88a1df371f53d9ca59 inherit pub_methods_classcds_1_1intrusive_1_1_basket_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor clears the queue.  <a href="#a48bfd4b13cf70c88a1df371f53d9ca59"></a><br/></td></tr>
<tr class="memitem:afb038030c7736e99f32e1113438b7f4a inherit pub_methods_classcds_1_1intrusive_1_1_basket_queue"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_basket_queue.html#afb038030c7736e99f32e1113438b7f4a">size</a> () const</td></tr>
<tr class="memdesc:afb038030c7736e99f32e1113438b7f4a inherit pub_methods_classcds_1_1intrusive_1_1_basket_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns queue's item count.  <a href="#afb038030c7736e99f32e1113438b7f4a"></a><br/></td></tr>
<tr class="memitem:ad215e4438fe009f1e607d5fc33b41666 inherit pub_methods_classcds_1_1intrusive_1_1_basket_queue"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad215e4438fe009f1e607d5fc33b41666"></a>
const <a class="el" href="classcds_1_1intrusive_1_1_basket_queue.html#a58a71ef0a817457db6788b504afda144">stat</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_basket_queue.html#ad215e4438fe009f1e607d5fc33b41666">statistics</a> () const</td></tr>
<tr class="memdesc:ad215e4438fe009f1e607d5fc33b41666 inherit pub_methods_classcds_1_1intrusive_1_1_basket_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to internal statistics. <br/></td></tr>
<tr class="memitem:ae8dfbc76add1877a4c716b4f546f0e75 inherit pub_methods_classcds_1_1intrusive_1_1_basket_queue"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_basket_queue.html#ae8dfbc76add1877a4c716b4f546f0e75">enqueue</a> (<a class="el" href="classcds_1_1intrusive_1_1_basket_queue.html#abdd98d36c2edf1b928e482980e66b079">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:ae8dfbc76add1877a4c716b4f546f0e75 inherit pub_methods_classcds_1_1intrusive_1_1_basket_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues <code>val</code> value into the queue.  <a href="#ae8dfbc76add1877a4c716b4f546f0e75"></a><br/></td></tr>
<tr class="memitem:a85d1658380b88ef4c791870704ca26ff inherit pub_methods_classcds_1_1intrusive_1_1_basket_queue"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_basket_queue.html#abdd98d36c2edf1b928e482980e66b079">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_basket_queue.html#a85d1658380b88ef4c791870704ca26ff">dequeue</a> ()</td></tr>
<tr class="memdesc:a85d1658380b88ef4c791870704ca26ff inherit pub_methods_classcds_1_1intrusive_1_1_basket_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dequeues a value from the queue.  <a href="#a85d1658380b88ef4c791870704ca26ff"></a><br/></td></tr>
<tr class="memitem:a7aa85d7b88da1cf7907f61f60f0507e1 inherit pub_methods_classcds_1_1intrusive_1_1_basket_queue"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7aa85d7b88da1cf7907f61f60f0507e1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_basket_queue.html#a7aa85d7b88da1cf7907f61f60f0507e1">push</a> (<a class="el" href="classcds_1_1intrusive_1_1_basket_queue.html#abdd98d36c2edf1b928e482980e66b079">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a7aa85d7b88da1cf7907f61f60f0507e1 inherit pub_methods_classcds_1_1intrusive_1_1_basket_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym for enqueue function. <br/></td></tr>
<tr class="memitem:ab28d98dab18453622e1a0045eacc9a60 inherit pub_methods_classcds_1_1intrusive_1_1_basket_queue"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab28d98dab18453622e1a0045eacc9a60"></a>
<a class="el" href="classcds_1_1intrusive_1_1_basket_queue.html#abdd98d36c2edf1b928e482980e66b079">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_basket_queue.html#ab28d98dab18453622e1a0045eacc9a60">pop</a> ()</td></tr>
<tr class="memdesc:ab28d98dab18453622e1a0045eacc9a60 inherit pub_methods_classcds_1_1intrusive_1_1_basket_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym for dequeue function. <br/></td></tr>
<tr class="memitem:ada1a4a32828bd0dbbfced7294fe57484 inherit pub_methods_classcds_1_1intrusive_1_1_basket_queue"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_basket_queue.html#ada1a4a32828bd0dbbfced7294fe57484">empty</a> ()</td></tr>
<tr class="memdesc:ada1a4a32828bd0dbbfced7294fe57484 inherit pub_methods_classcds_1_1intrusive_1_1_basket_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the queue is empty.  <a href="#ada1a4a32828bd0dbbfced7294fe57484"></a><br/></td></tr>
<tr class="memitem:a23671e156404fda93bce9dc041d654e8 inherit pub_methods_classcds_1_1intrusive_1_1_basket_queue"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_basket_queue.html#a23671e156404fda93bce9dc041d654e8">clear</a> ()</td></tr>
<tr class="memdesc:a23671e156404fda93bce9dc041d654e8 inherit pub_methods_classcds_1_1intrusive_1_1_basket_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the queue.  <a href="#a23671e156404fda93bce9dc041d654e8"></a><br/></td></tr>
<tr class="inherit_header pub_static_attribs_classcds_1_1intrusive_1_1_basket_queue"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classcds_1_1intrusive_1_1_basket_queue')"><img src="closed.png" alt="-"/>&nbsp;Static Private Attributes inherited from <a class="el" href="classcds_1_1intrusive_1_1_basket_queue.html">cds::intrusive::BasketQueue< GC, intrusive::basket_queue::node< T >, Options... ></a></td></tr>
<tr class="memitem:a8d9a27425014a10f7fb9ede35bdad824 inherit pub_static_attribs_classcds_1_1intrusive_1_1_basket_queue"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d9a27425014a10f7fb9ede35bdad824"></a>
static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_basket_queue.html#a8d9a27425014a10f7fb9ede35bdad824">m_nHazardPtrCount</a></td></tr>
<tr class="memdesc:a8d9a27425014a10f7fb9ede35bdad824 inherit pub_static_attribs_classcds_1_1intrusive_1_1_basket_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of hazard pointer required for the algorithm. <br/></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename GC, typename T, typename... Options&gt;<br/>
class cds::container::BasketQueue&lt; GC, T, Options &gt;</h3>

<p>Basket lock-free queue (non-intrusive variant) </p>
<p>It is non-intrusive version of basket queue algorithm based on <a class="el" href="classcds_1_1intrusive_1_1_basket_queue.html" title="Basket lock-free queue (intrusive variant)">intrusive::BasketQueue</a> counterpart.</p>
<dl class="section user"><dt>Source:</dt><dd>[2007] Moshe Hoffman, Ori Shalev, Nir Shavit "The Baskets Queue"</dd></dl>
<p><b>Key idea</b></p>
<p>In the “basket” approach, instead of the traditional ordered list of nodes, the queue consists of an ordered list of groups of nodes (logical baskets). The order of nodes in each basket need not be specified, and in fact, it is easiest to maintain them in LIFO order. The baskets fulfill the following basic rules:</p>
<ul>
<li>Each basket has a time interval in which all its nodes’ enqueue operations overlap.</li>
<li>The baskets are ordered by the order of their respective time intervals.</li>
<li>For each basket, its nodes’ dequeue operations occur after its time interval.</li>
<li>The dequeue operations are performed according to the order of baskets.</li>
</ul>
<p>Two properties define the FIFO order of nodes:</p>
<ul>
<li>The order of nodes in a basket is not specified.</li>
<li>The order of nodes in different baskets is the FIFO-order of their respective baskets.</li>
</ul>
<p>In algorithms such as the MS-queue or optimistic queue, threads enqueue items by applying a Compare-and-swap (CAS) operation to the queue’s tail pointer, and all the threads that fail on a particular CAS operation (and also the winner of that CAS) overlap in time. In particular, they share the time interval of the CAS operation itself. Hence, all the threads that fail to CAS on the tail-node of the queue may be inserted into the same basket. By integrating the basket-mechanism as the back-off mechanism, the time usually spent on backing-off before trying to link onto the new tail, can now be utilized to insert the failed operations into the basket, allowing enqueues to complete sooner. In the meantime, the next successful CAS operations by enqueues allow new baskets to be formed down the list, and these can be filled concurrently. Moreover, the failed operations don’t retry their link attempt on the new tail, lowering the overall contention on it. This leads to a queue algorithm that unlike all former concurrent queue algorithms requires virtually no tuning of the backoff mechanisms to reduce contention, making the algorithm an attractive out-of-the-box queue.</p>
<p>In order to enqueue, just as in <a class="el" href="classcds_1_1container_1_1_m_s_queue.html" title="Michael &amp; Scott lock-free queue.">MSQueue</a>, a thread first tries to link the new node to the last node. If it failed to do so, then another thread has already succeeded. Thus it tries to insert the new node into the new basket that was created by the winner thread. To dequeue a node, a thread first reads the head of the queue to obtain the oldest basket. It may then dequeue any node in the oldest basket.</p>
<p>Template arguments:</p>
<ul>
<li><code>GC</code> - garbage collector type: <a class="el" href="classcds_1_1gc_1_1_h_p.html" title="Hazard Pointer garbage collector.">gc::HP</a>, <a class="el" href="classcds_1_1gc_1_1_h_r_c.html" title="Gidenstam&#39;s garbage collector.">gc::HRC</a>, <a class="el" href="classcds_1_1gc_1_1_p_t_b.html" title="Pass-the-Buck garbage collector.">gc::PTB</a></li>
<li><code>T</code> is a type stored in the queue. It should be default-constructible, copy-constructible, assignable type.</li>
<li><code>Options</code> - options</li>
</ul>
<p>Permissible <code>Options:</code> </p>
<ul>
<li><a class="el" href="structcds_1_1opt_1_1allocator.html" title="[type-option] Option setter for an allocator">opt::allocator</a> - allocator (like <code>std::allocator</code>). Default is <a class="el" href="user__setup_2allocator_8h.html#ad5fb7e3cbe8cf24295f0ea3c165a2d82">CDS_DEFAULT_ALLOCATOR</a></li>
<li><a class="el" href="structcds_1_1opt_1_1back__off.html" title="[type-option] Back-off strategy option setter">opt::back_off</a> - back-off strategy used. If the option is not specified, the <a class="el" href="structcds_1_1backoff_1_1empty.html" title="Empty backoff strategy. Do nothing.">cds::backoff::empty</a> is used</li>
<li><a class="el" href="structcds_1_1opt_1_1item__counter.html" title="[type-option] Option setter for item counting">opt::item_counter</a> - the type of item counting feature. Default is <a class="el" href="classcds_1_1atomicity_1_1empty__item__counter.html">atomicity::empty_item_counter</a></li>
<li><a class="el" href="structcds_1_1opt_1_1stat.html" title="[type-option] Generic option setter for statisitcs">opt::stat</a> - the type to gather internal statistics for debugging and profiling purposes. Possible option value are: <a class="el" href="structcds_1_1intrusive_1_1basket__queue_1_1stat.html" title="Basket queue internal statistics. May be used for debugging or profiling.">intrusive::basket_queue::stat</a>, <a class="el" href="structcds_1_1intrusive_1_1basket__queue_1_1dummy__stat.html" title="Dummy basket queue statistics - no counting is performed. Support interface like stat.">intrusive::basket_queue::dummy_stat</a> (the default), user-provided class that supports <a class="el" href="structcds_1_1intrusive_1_1basket__queue_1_1stat.html" title="Basket queue internal statistics. May be used for debugging or profiling.">intrusive::basket_queue::stat</a> interface. Generic option <a class="el" href="structcds_1_1intrusive_1_1queue__stat.html" title="Queue internal statistics. May be used for debugging or profiling.">intrusive::queue_stat</a> and <a class="el" href="structcds_1_1intrusive_1_1queue__dummy__stat.html" title="Dummy queue statistics - no counting is performed. Support interface like queue_stat.">intrusive::queue_dummy_stat</a> are acceptable too, however, they will be automatically converted to <a class="el" href="structcds_1_1intrusive_1_1basket__queue_1_1stat.html" title="Basket queue internal statistics. May be used for debugging or profiling.">intrusive::basket_queue::stat</a> and <a class="el" href="structcds_1_1intrusive_1_1basket__queue_1_1dummy__stat.html" title="Dummy basket queue statistics - no counting is performed. Support interface like stat.">intrusive::basket_queue::dummy_stat</a> respectively.</li>
<li><a class="el" href="structcds_1_1opt_1_1alignment.html" title="[value-option] Alignment option setter">opt::alignment</a> - the alignment for internal queue data. Default is <a class="el" href="namespacecds_1_1opt.html#aa645d9d6fea0b1355513b3608efd6d9ca60b877c6bb50b49d022ecfce77564167" title="use cache line size defined in cds/user_setup/cache_line.h">opt::cache_line_alignment</a></li>
<li><a class="el" href="structcds_1_1opt_1_1memory__model.html" title="[type-option] Option setter for C++ memory model">opt::memory_model</a> - C++ memory ordering model. Can be <a class="el" href="structcds_1_1opt_1_1v_1_1relaxed__ordering.html" title="Relaxed memory ordering model.">opt::v::relaxed_ordering</a> (relaxed memory model, the default) or <a class="el" href="structcds_1_1opt_1_1v_1_1sequential__consistent.html" title="Sequential consistent memory ordering model.">opt::v::sequential_consistent</a> (sequentially consisnent memory model). </li>
</ul>
</div><h2>Member Function Documentation</h2>
<a class="anchor" id="a5023f241c17fed72cd436ce164d389f6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC , typename T , typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcds_1_1container_1_1_basket_queue.html">cds::container::BasketQueue</a>&lt; GC, T, Options &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the queue. </p>
<p>The function repeatedly calls <a class="el" href="classcds_1_1container_1_1_basket_queue.html#aa9a84a790dfe2f76c0d67089d76d1a0a">dequeue</a> until it returns NULL. </p>

</div>
</div>
<a class="anchor" id="aa9a84a790dfe2f76c0d67089d76d1a0a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC , typename T , typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename Type , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_basket_queue.html">cds::container::BasketQueue</a>&lt; GC, T, Options &gt;::dequeue </td>
          <td>(</td>
          <td class="paramtype">Type &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dequeues a value using copy functor. </p>
<p><code>Func</code> is a functor called to copy dequeued value to <code>dest</code> of type <code>Type</code> which may be differ from type <code>T</code> stored in the queue. The functor's interface is: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>myFunctor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()(Type&amp; dest, T <span class="keyword">const</span>&amp; data)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Code to copy \p data to \p dest</span></div>
<div class="line">        dest = data ;</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p> You may use <code>boost:ref</code> construction to pass functor <code>f</code> by reference.</p>
<p><b>Requirements</b> The functor <code>Func</code> should not throw any exception. </p>

</div>
</div>
<a class="anchor" id="a1e408a443ce1683f1f65b88a4e0ed5a5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC , typename T , typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_basket_queue.html">cds::container::BasketQueue</a>&lt; GC, T, Options &gt;::dequeue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1container_1_1_basket_queue.html#abb4a38d60c1d5021c5ba24a94ab16ad8">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dequeues a value from the queue. </p>
<p>If queue is not empty, the function returns <code>true</code>, <code>dest</code> contains copy of dequeued value. The assignment operator for type <a class="el" href="classcds_1_1container_1_1_basket_queue.html#abb4a38d60c1d5021c5ba24a94ab16ad8">value_type</a> is invoked. If queue is empty, the function returns <code>false</code>, <code>dest</code> is unchanged. </p>

</div>
</div>
<a class="anchor" id="aad45c8a128556519ed5f16195347b690"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC , typename T , typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_basket_queue.html">cds::container::BasketQueue</a>&lt; GC, T, Options &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the queue is empty. </p>
<p>Note that ithis function is not <code>const</code>. The function is based on <a class="el" href="classcds_1_1container_1_1_basket_queue.html#aa9a84a790dfe2f76c0d67089d76d1a0a">dequeue</a> algorithm. </p>

</div>
</div>
<a class="anchor" id="aae3a0ca675ebee5f511fc50b4186350b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC , typename T , typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_basket_queue.html">cds::container::BasketQueue</a>&lt; GC, T, Options &gt;::enqueue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcds_1_1container_1_1_basket_queue.html#abb4a38d60c1d5021c5ba24a94ab16ad8">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enqueues <code>val</code> value into the queue. </p>
<p>The function makes queue node in dynamic memory calling copy constructor for <code>val</code> and then it calls <a class="el" href="classcds_1_1intrusive_1_1_basket_queue.html#ae8dfbc76add1877a4c716b4f546f0e75" title="Enqueues val value into the queue.">intrusive::BasketQueue::enqueue</a>. Returns <code>true</code> if success, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a6b4244e03e4181e339a7da6181aed4d2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC , typename T , typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename Type , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_basket_queue.html">cds::container::BasketQueue</a>&lt; GC, T, Options &gt;::enqueue </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enqueues <code>data</code> to queue using copy functor. </p>
<p><code>Func</code> is a functor called to copy value <code>data</code> of type <code>Type</code> which may be differ from type <code>T</code> stored in the queue. The functor's interface is: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>myFunctor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()(T&amp; dest, Type <span class="keyword">const</span>&amp; data)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// // Code to copy \p data to \p dest</span></div>
<div class="line">        dest = data ;</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p> You may use <code>boost:ref</code> construction to pass functor <code>f</code> by reference.</p>
<p><b>Requirements</b> The functor <code>Func</code> should not throw any exception. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cds/container/basket_queue.h</li>
</ul>
</div><!-- contents -->
		<hr/>
		<div align="right">
			<b>cds</b> <b>1.2.0</b> 
			Developed by <i>Maxim Khiszinsky aka khizmax</i> 2007 - 2012
			<br/>
			<i>Autogenerated Mon Aug 20 2012 22:32:38 by Doxygen 1.8.1.2</i>
		</div>
	</BODY>
</HTML>
