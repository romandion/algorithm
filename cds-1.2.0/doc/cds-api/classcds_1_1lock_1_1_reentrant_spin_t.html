<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>cds: cds::lock::ReentrantSpinT&lt; Integral, Backoff &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">cds
   &#160;<span id="projectnumber">1.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecds.html">cds</a></li><li class="navelem"><a class="el" href="namespacecds_1_1lock.html">lock</a></li><li class="navelem"><a class="el" href="classcds_1_1lock_1_1_reentrant_spin_t.html">ReentrantSpinT</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">cds::lock::ReentrantSpinT&lt; Integral, Backoff &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Recursive spin lock.  
 <a href="classcds_1_1lock_1_1_reentrant_spin_t.html#details">More...</a></p>

<p><code>#include &lt;cds/lock/spinlock.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a97a31f3213c6a62e46b98c423cee905d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97a31f3213c6a62e46b98c423cee905d"></a>
typedef Integral&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1lock_1_1_reentrant_spin_t.html#a97a31f3213c6a62e46b98c423cee905d">integral_type</a></td></tr>
<tr class="memdesc:a97a31f3213c6a62e46b98c423cee905d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The integral type. <br/></td></tr>
<tr class="memitem:aa18bbb659881d289822df7212cea1739"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa18bbb659881d289822df7212cea1739"></a>
typedef Backoff&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1lock_1_1_reentrant_spin_t.html#aa18bbb659881d289822df7212cea1739">backoff_strategy</a></td></tr>
<tr class="memdesc:aa18bbb659881d289822df7212cea1739"><td class="mdescLeft">&#160;</td><td class="mdescRight">The backoff type. <br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6a7cc6db0aa3ab4dbcc6e59610d6a5ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a7cc6db0aa3ab4dbcc6e59610d6a5ad"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1lock_1_1_reentrant_spin_t.html#a6a7cc6db0aa3ab4dbcc6e59610d6a5ad">ReentrantSpinT</a> ()</td></tr>
<tr class="memdesc:a6a7cc6db0aa3ab4dbcc6e59610d6a5ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor initializes spin to free (unlocked) state. <br/></td></tr>
<tr class="memitem:aba854c099fa00af861a8aa909dd51847"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1lock_1_1_reentrant_spin_t.html#aba854c099fa00af861a8aa909dd51847">ReentrantSpinT</a> (const <a class="el" href="classcds_1_1lock_1_1_reentrant_spin_t.html">ReentrantSpinT</a>&lt; Integral, Backoff &gt; &amp;)</td></tr>
<tr class="memdesc:aba854c099fa00af861a8aa909dd51847"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy copy constructor.  <a href="#aba854c099fa00af861a8aa909dd51847"></a><br/></td></tr>
<tr class="memitem:a7555c5b14ea0b06a37451364f2b37e6c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7555c5b14ea0b06a37451364f2b37e6c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1lock_1_1_reentrant_spin_t.html#a7555c5b14ea0b06a37451364f2b37e6c">ReentrantSpinT</a> (bool bLocked)</td></tr>
<tr class="memdesc:a7555c5b14ea0b06a37451364f2b37e6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct object for specified state. <br/></td></tr>
<tr class="memitem:af87487a430d3038bd5b75a025991f8ee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af87487a430d3038bd5b75a025991f8ee"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1lock_1_1_reentrant_spin_t.html#af87487a430d3038bd5b75a025991f8ee">tryLock</a> ()</td></tr>
<tr class="memdesc:af87487a430d3038bd5b75a025991f8ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to lock the spin-lock. If spin-lock is free the current thread owns it. Return <code>true</code> if lock is success. <br/></td></tr>
<tr class="memitem:aa003da112d1a6c953386e77c8e7929f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1lock_1_1_reentrant_spin_t.html#aa003da112d1a6c953386e77c8e7929f1">tryLock</a> (unsigned int nTryCount)</td></tr>
<tr class="memdesc:aa003da112d1a6c953386e77c8e7929f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to lock the object.  <a href="#aa003da112d1a6c953386e77c8e7929f1"></a><br/></td></tr>
<tr class="memitem:abc195d8fb477c9143f6cad37d921bad8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc195d8fb477c9143f6cad37d921bad8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1lock_1_1_reentrant_spin_t.html#abc195d8fb477c9143f6cad37d921bad8">lock</a> ()</td></tr>
<tr class="memdesc:abc195d8fb477c9143f6cad37d921bad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the object waits if it is busy. <br/></td></tr>
<tr class="memitem:ac374240bbe6d96f6f2c2b33db4cfd882"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac374240bbe6d96f6f2c2b33db4cfd882"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1lock_1_1_reentrant_spin_t.html#ac374240bbe6d96f6f2c2b33db4cfd882">unlock</a> ()</td></tr>
<tr class="memdesc:ac374240bbe6d96f6f2c2b33db4cfd882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock the spin-lock. Return <code>true</code> if the current thread is owner of spin-lock <code>false</code> otherwise. <br/></td></tr>
<tr class="memitem:aa534a1869e272a1b34d7083cb5ce190e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa534a1869e272a1b34d7083cb5ce190e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1lock_1_1_reentrant_spin_t.html#aa534a1869e272a1b34d7083cb5ce190e">changeOwner</a> (OS::ThreadId newOwnerId)</td></tr>
<tr class="memdesc:aa534a1869e272a1b34d7083cb5ce190e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the owner of locked spin-lock. May be called by thread that is owner of the spin-lock. <br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a2fc6a8d11e14744af1ae81c3da1d713e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2fc6a8d11e14744af1ae81c3da1d713e"></a>
typedef OS::ThreadId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1lock_1_1_reentrant_spin_t.html#a2fc6a8d11e14744af1ae81c3da1d713e">thread_id</a></td></tr>
<tr class="memdesc:a2fc6a8d11e14744af1ae81c3da1d713e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of thread id. <br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a607b0188780feca419074a01bc1fc487"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a607b0188780feca419074a01bc1fc487"></a>
std::atomic&lt; <a class="el" href="classcds_1_1lock_1_1_reentrant_spin_t.html#a97a31f3213c6a62e46b98c423cee905d">integral_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1lock_1_1_reentrant_spin_t.html#a607b0188780feca419074a01bc1fc487">m_spin</a></td></tr>
<tr class="memdesc:a607b0188780feca419074a01bc1fc487"><td class="mdescLeft">&#160;</td><td class="mdescRight">spin-lock atomic <br/></td></tr>
<tr class="memitem:af051b56bcdcee0359737204900218aff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af051b56bcdcee0359737204900218aff"></a>
<a class="el" href="classcds_1_1lock_1_1_reentrant_spin_t.html#a2fc6a8d11e14744af1ae81c3da1d713e">thread_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1lock_1_1_reentrant_spin_t.html#af051b56bcdcee0359737204900218aff">m_OwnerId</a></td></tr>
<tr class="memdesc:af051b56bcdcee0359737204900218aff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Owner thread id. If spin-lock is not locked it usually equals to OS::nullThreadId() <br/></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Integral, class Backoff&gt;<br/>
class cds::lock::ReentrantSpinT&lt; Integral, Backoff &gt;</h3>

<p>Recursive spin lock. </p>
<p>Allows recursive calls: the owner thread may recursive enter to critical section guarded by the spin-lock.</p>
<p>Template parameters:</p>
<ul>
<li><code>Integral</code> one of integral atomic type: <code>unsigned int</code>, <code>int</code>, and others</li>
<li><code>Backoff</code> backoff strategy. Used when spin lock is locked </li>
</ul>
</div><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aba854c099fa00af861a8aa909dd51847"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Integral , class Backoff &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1lock_1_1_reentrant_spin_t.html">cds::lock::ReentrantSpinT</a>&lt; Integral, Backoff &gt;::<a class="el" href="classcds_1_1lock_1_1_reentrant_spin_t.html">ReentrantSpinT</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcds_1_1lock_1_1_reentrant_spin_t.html">ReentrantSpinT</a>&lt; Integral, Backoff &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dummy copy constructor. </p>
<p>In theory, spin-lock cannot be copied. However, it is not practical. Therefore, we provide dummy copy constructor that do no copy in fact. The ctor initializes the spin to free (unlocked) state like default ctor. </p>

</div>
</div>
<h2>Member Function Documentation</h2>
<a class="anchor" id="aa003da112d1a6c953386e77c8e7929f1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Integral , class Backoff &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1lock_1_1_reentrant_spin_t.html">cds::lock::ReentrantSpinT</a>&lt; Integral, Backoff &gt;::tryLock </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nTryCount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to lock the object. </p>
<p>If spin-lock is locked the method repeats attempts to own spin-lock up to <code>nTryCount</code> times. Between attempts <code>backoff()</code> is called. Return <code>true</code> if current thread owns the lock <code>false</code> otherwise </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cds/lock/spinlock.h</li>
</ul>
</div><!-- contents -->
		<hr/>
		<div align="right">
			<b>cds</b> <b>1.2.0</b> 
			Developed by <i>Maxim Khiszinsky aka khizmax</i> 2007 - 2012
			<br/>
			<i>Autogenerated Mon Aug 20 2012 22:32:42 by Doxygen 1.8.1.2</i>
		</div>
	</BODY>
</HTML>
