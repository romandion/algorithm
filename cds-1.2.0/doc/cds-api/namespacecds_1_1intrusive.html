<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>cds: cds::intrusive Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">cds
   &#160;<span id="projectnumber">1.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecds.html">cds</a></li><li class="navelem"><a class="el" href="namespacecds_1_1intrusive.html">intrusive</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Data Structures</a>  </div>
  <div class="headertitle">
<div class="title">cds::intrusive Namespace Reference<div class="ingroups"><a class="el" href="group__cds__intrusive__containers.html">Intrusive containers</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Intrusive containers.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacecds_1_1intrusive_1_1basket__queue"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecds_1_1intrusive_1_1basket__queue.html">basket_queue</a></td></tr>
<tr class="memdesc:namespacecds_1_1intrusive_1_1basket__queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Baskets queue related definitions. <br/></td></tr>
<tr class="memitem:namespacecds_1_1intrusive_1_1lazy__list"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecds_1_1intrusive_1_1lazy__list.html">lazy_list</a></td></tr>
<tr class="memdesc:namespacecds_1_1intrusive_1_1lazy__list"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcds_1_1intrusive_1_1_lazy_list.html" title="Lazy ordered single-linked list.">LazyList</a> ordered list related definitions. <br/></td></tr>
<tr class="memitem:namespacecds_1_1intrusive_1_1michael__deque"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecds_1_1intrusive_1_1michael__deque.html">michael_deque</a></td></tr>
<tr class="memdesc:namespacecds_1_1intrusive_1_1michael__deque"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcds_1_1intrusive_1_1_michael_deque.html" title="Michael&#39;s intrusive deque.">MichaelDeque</a> related definitions. <br/></td></tr>
<tr class="memitem:namespacecds_1_1intrusive_1_1michael__list"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecds_1_1intrusive_1_1michael__list.html">michael_list</a></td></tr>
<tr class="memdesc:namespacecds_1_1intrusive_1_1michael__list"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html" title="Michael&#39;s lock-free ordered single-linked list.">MichaelList</a> ordered list related definitions. <br/></td></tr>
<tr class="memitem:namespacecds_1_1intrusive_1_1michael__set"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecds_1_1intrusive_1_1michael__set.html">michael_set</a></td></tr>
<tr class="memdesc:namespacecds_1_1intrusive_1_1michael__set"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcds_1_1intrusive_1_1_michael_hash_set.html" title="Michael&#39;s hash set.">MichaelHashSet</a> related definitions. <br/></td></tr>
<tr class="memitem:namespacecds_1_1intrusive_1_1opt"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecds_1_1intrusive_1_1opt.html">opt</a></td></tr>
<tr class="memdesc:namespacecds_1_1intrusive_1_1opt"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common options for intrusive containers. <br/></td></tr>
<tr class="memitem:namespacecds_1_1intrusive_1_1optimistic__queue"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecds_1_1intrusive_1_1optimistic__queue.html">optimistic_queue</a></td></tr>
<tr class="memdesc:namespacecds_1_1intrusive_1_1optimistic__queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimistic queue related definitions. <br/></td></tr>
<tr class="memitem:namespacecds_1_1intrusive_1_1single__link"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecds_1_1intrusive_1_1single__link.html">single_link</a></td></tr>
<tr class="memdesc:namespacecds_1_1intrusive_1_1single__link"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions common for single-linked data structures. <br/></td></tr>
<tr class="memitem:namespacecds_1_1intrusive_1_1split__list"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecds_1_1intrusive_1_1split__list.html">split_list</a></td></tr>
<tr class="memdesc:namespacecds_1_1intrusive_1_1split__list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split-ordered list related definitions. <br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcds_1_1intrusive_1_1node__traits.html">node_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container's node traits.  <a href="structcds_1_1intrusive_1_1node__traits.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcds_1_1intrusive_1_1get__node__traits.html">get_node_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node traits selector metafunction.  <a href="structcds_1_1intrusive_1_1get__node__traits.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_basket_queue.html">BasketQueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basket lock-free queue (intrusive variant)  <a href="classcds_1_1intrusive_1_1_basket_queue.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcds_1_1intrusive_1_1deque__stat.html">deque_stat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deque internal statistics. May be used for debugging or profiling.  <a href="structcds_1_1intrusive_1_1deque__stat.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcds_1_1intrusive_1_1deque__dummy__stat.html">deque_dummy_stat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy deque statistics - no counting is performed. Support interface like <a class="el" href="structcds_1_1intrusive_1_1deque__stat.html">deque_stat</a>.  <a href="structcds_1_1intrusive_1_1deque__dummy__stat.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_lazy_list.html">LazyList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lazy ordered single-linked list.  <a href="classcds_1_1intrusive_1_1_lazy_list.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_lazy_list_3_01gc_1_1nogc_00_01_t_00_01_traits_01_4.html">LazyList&lt; gc::nogc, T, Traits &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lazy ordered single-linked list (template specialization for <a class="el" href="classcds_1_1gc_1_1nogc.html" title="No garbage collecting.">gc::nogc</a>)  <a href="classcds_1_1intrusive_1_1_lazy_list_3_01gc_1_1nogc_00_01_t_00_01_traits_01_4.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_deque.html">MichaelDeque</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Michael's intrusive deque.  <a href="classcds_1_1intrusive_1_1_michael_deque.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html">MichaelList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Michael's lock-free ordered single-linked list.  <a href="classcds_1_1intrusive_1_1_michael_list.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_list_3_01gc_1_1nogc_00_01_t_00_01_traits_01_4.html">MichaelList&lt; gc::nogc, T, Traits &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Michael's lock-free ordered single-linked list (template specialization for <a class="el" href="classcds_1_1gc_1_1nogc.html" title="No garbage collecting.">gc::nogc</a>)  <a href="classcds_1_1intrusive_1_1_michael_list_3_01gc_1_1nogc_00_01_t_00_01_traits_01_4.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_hash_set.html">MichaelHashSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Michael's hash set.  <a href="classcds_1_1intrusive_1_1_michael_hash_set.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_hash_set_3_01gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html">MichaelHashSet&lt; gc::nogc, OrderedList, Traits &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Michael's hash set (template specialization for <a class="el" href="classcds_1_1gc_1_1nogc.html" title="No garbage collecting.">gc::nogc</a>)  <a href="classcds_1_1intrusive_1_1_michael_hash_set_3_01gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_moir_queue.html">MoirQueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variation of Michael &amp; Scott's lock-free queue (intrusive variant)  <a href="classcds_1_1intrusive_1_1_moir_queue.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_m_s_queue.html">MSQueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Michael &amp; Scott's lock-free queue (intrusive variant)  <a href="classcds_1_1intrusive_1_1_m_s_queue.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_optimistic_queue.html">OptimisticQueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimistic queue.  <a href="classcds_1_1intrusive_1_1_optimistic_queue.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcds_1_1intrusive_1_1queue__stat.html">queue_stat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue internal statistics. May be used for debugging or profiling.  <a href="structcds_1_1intrusive_1_1queue__stat.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcds_1_1intrusive_1_1queue__dummy__stat.html">queue_dummy_stat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy queue statistics - no counting is performed. Support interface like <a class="el" href="structcds_1_1intrusive_1_1queue__stat.html">queue_stat</a>.  <a href="structcds_1_1intrusive_1_1queue__dummy__stat.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html">SplitListSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split-ordered list.  <a href="classcds_1_1intrusive_1_1_split_list_set.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html">SplitListSet&lt; gc::nogc, OrderedList, Traits &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split-ordered list (template specialization for <a class="el" href="classcds_1_1gc_1_1nogc.html" title="No garbage collecting.">gc::nogc</a>)  <a href="classcds_1_1intrusive_1_1_split_list_set_3_01gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcds_1_1intrusive_1_1stack__stat.html">stack_stat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stack internal statistics. May be used for debugging or profiling.  <a href="structcds_1_1intrusive_1_1stack__stat.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcds_1_1intrusive_1_1stack__dummy__stat.html">stack_dummy_stat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy stack statistics - no counting is performed. Support interface like <a class="el" href="structcds_1_1intrusive_1_1stack__stat.html">stack_stat</a>.  <a href="structcds_1_1intrusive_1_1stack__dummy__stat.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html">TreiberStack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Treiber stack.  <a href="classcds_1_1intrusive_1_1_treiber_stack.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_tsigas_cycle_queue.html">TsigasCycleQueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking cyclic queue discovered by Philippas Tsigas and Yi Zhang.  <a href="classcds_1_1intrusive_1_1_tsigas_cycle_queue.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_vyukov_m_p_m_c_cycle_queue.html">VyukovMPMCCycleQueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vyukov's MPMC bounded queue.  <a href="classcds_1_1intrusive_1_1_vyukov_m_p_m_c_cycle_queue.html#details">More...</a><br/></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Intrusive containers. </p>
<p>The namespace <a class="el" href="namespacecds_1_1intrusive.html" title="Intrusive containers.">cds::intrusive</a> contains intrusive lock-free containers. The idea comes from <code>boost::intrusive</code> library, see <a href="http://boost.org/doc/">http://boost.org/doc/</a> as a good introduction to intrusive approach. The intrusive containers of libcds library is developed as close to boost::intrusive</p>
<p>In terms of lock-free approach, the main advantage of intrusive containers is that no memory allocation is performed to maintain container items. However, additional requirements is imposed for types and values that can be stored in intrusive container. See the container documentation for details.</p>
<p>Restriction for Gidenstam's garbage collector <a class="el" href="classcds_1_1gc_1_1_h_r_c.html" title="Gidenstam&#39;s garbage collector.">cds::gc::HRC</a>: the Gidenstam's garbage collector makes additional requirements to type of item in intrusive container. Therefore, for this GC only <code>base_hook</code> is allowed as the value of <a class="el" href="structcds_1_1intrusive_1_1opt_1_1hook.html" title="Hook option.">opt::hook</a> option.</p>
<p><a class="anchor" id="cds_intrusive_item_destroying"></a></p>
<dl class="section user"><dt>Destroying items</dt><dd></dd></dl>
<p>It should be very careful when destroying an item removed from intrusive container. In other threads the references to popped item may exists some time after removing. To destroy the removed item in thread-safe manner you should call static function <code>retire</code> of garbage collector you use, for example: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>destroyer  {</div>
<div class="line">    <span class="keywordtype">void</span> operator ()( my_type * p )</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">delete</span> p    ;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1intrusive_1_1_treiber_stack.html" title="Treiber stack.">cds::intrusive::TreiberStack&lt; cds::gc::HP, my_type, cds::opt::disposer&lt; destroyer &gt;</a> &gt; stack ;</div>
<div class="line">stack s ;</div>
<div class="line"></div>
<div class="line"><span class="comment">// ....</span></div>
<div class="line"></div>
<div class="line">my_type * p = s.<a class="code" href="classcds_1_1intrusive_1_1_treiber_stack.html#a1c0af71eebdef539fd74dfc28c12fa46" title="Pop an item from the stack.">pop</a>() ;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">if</span> ( p ) {</div>
<div class="line">    <span class="comment">// It is wrong</span></div>
<div class="line">    <span class="comment">// delete p ;</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// It is correct</span></div>
<div class="line">    cds::gc:HP::retire&lt; destroyer &gt;( p ) ;</div>
<div class="line">}</div>
</div><!-- fragment --><p> The situation becomes even more complicated when you want store items in different intrusive containers. In this case the best way is using reference counting: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>my_type {</div>
<div class="line">    ...</div>
<div class="line">    std::atomic&lt;unsigned int&gt; nRefCount ;</div>
<div class="line"></div>
<div class="line">    my_type()</div>
<div class="line">        : nRefCount(0)</div>
<div class="line">    {}</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>destroyer  {</div>
<div class="line">    <span class="keywordtype">void</span> operator ()( my_type * p )</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> ( --p-&gt;nRefCount == 0 )</div>
<div class="line">            <span class="keyword">delete</span> p    ;   <span class="comment">// delete only after no reference pointing to p</span></div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1intrusive_1_1_treiber_stack.html" title="Treiber stack.">cds::intrusive::TreiberStack&lt; cds::gc::HP, my_type, cds::opt::disposer&lt; destroyer &gt;</a> &gt; stack ;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1intrusive_1_1_m_s_queue.html" title="Michael &amp; Scott&#39;s lock-free queue (intrusive variant)">cds::intrusive::MSQueue&lt; cds::gc::HP, my_type, cds::opt::disposer&lt; destroyer &gt;</a> &gt; queue ;</div>
<div class="line">stack s ;</div>
<div class="line">queue q ;</div>
<div class="line"></div>
<div class="line">my_type * v = <span class="keyword">new</span> my_type() ;</div>
<div class="line"></div>
<div class="line">v.nRefCount++   ; <span class="comment">// increment counter before pushing the item to the stack</span></div>
<div class="line">s.push(v)   ;</div>
<div class="line"></div>
<div class="line">v.nRefCount++   ; <span class="comment">// increment counter before pushing the item to the queue</span></div>
<div class="line">q.push(v)   ;</div>
<div class="line"></div>
<div class="line"><span class="comment">// ....</span></div>
<div class="line"></div>
<div class="line">my_type * ps = s.pop() ;</div>
<div class="line"><span class="keywordflow">if</span> ( ps ) {</div>
<div class="line">    <span class="comment">// It is wrong</span></div>
<div class="line">    <span class="comment">// delete ps ;</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// It is correct</span></div>
<div class="line">    cds::gc:HP::retire&lt; destroyer &gt;( ps ) ;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">my_type * pq = q.pop() ;</div>
<div class="line"><span class="keywordflow">if</span> ( pq ) {</div>
<div class="line">    <span class="comment">// It is wrong</span></div>
<div class="line">    <span class="comment">// delete pq ;</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// It is correct</span></div>
<div class="line">    cds::gc:HP::retire&lt; destroyer &gt;( pq ) ;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Violation of these rules may lead to a crash.</p>
<dl class="section user"><dt>Intrusive containers and Hazard Pointer-like garbage collectors</dt><dd></dd></dl>
<p>If you develop your intrusive container based on <b>libcds</b> library framework, you should take in the account the following. The main idea of garbage collectors (GC) based on Hazard Pointer schema is protecting a shared pointer by publishing it as a "hazard" one i.e. as a pointer that is changing at the current time and cannot be deleted at this moment. In intrusive container paradigm, the pointer to the node of the container and the pointer to the item stored in the container are not equal in the general case. However, any pointer to the node should be cast to the appropriate pointer to the container's item. In general, any item can be placed to some different intrusive containers simultaneously, and each of those container holds a unique pointer to its node that refers to the same item. When we protect a pointer, we want to protect an <b>item</b> pointer that is the invariant for any container stored that item. Conclusion: instead of protecting by GC's guard a pointer to an node you should convert it to the pointer to the item and then protect resulting item pointer. Otherwise an unpredictable result may occurs. </p>
</div></div><!-- contents -->
		<hr/>
		<div align="right">
			<b>cds</b> <b>1.2.0</b> 
			Developed by <i>Maxim Khiszinsky aka khizmax</i> 2007 - 2012
			<br/>
			<i>Autogenerated Mon Aug 20 2012 22:32:41 by Doxygen 1.8.1.2</i>
		</div>
	</BODY>
</HTML>
