<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>cds: cds::memory::michael::Heap&lt; Options &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">cds
   &#160;<span id="projectnumber">1.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecds.html">cds</a></li><li class="navelem"><a class="el" href="namespacecds_1_1memory.html">memory</a></li><li class="navelem"><a class="el" href="namespacecds_1_1memory_1_1michael.html">michael</a></li><li class="navelem"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html">Heap</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">cds::memory::michael::Heap&lt; Options &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Michael's allocator.  
 <a href="classcds_1_1memory_1_1michael_1_1_heap.html#details">More...</a></p>

<p><code>#include &lt;cds/memory/michael/allocator.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cds::memory::michael::Heap&lt; Options &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcds_1_1memory_1_1michael_1_1_heap.png" usemap="#cds::memory::michael::Heap&lt; Options &gt;_map" alt=""/>
  <map id="cds::memory::michael::Heap&lt; Options &gt;_map" name="cds::memory::michael::Heap&lt; Options &gt;_map">
<area href="classcds_1_1memory_1_1michael_1_1page__allocator.html" title="Page heap based on Heap." alt="cds::memory::michael::page_allocator&lt; Heap &gt;" shape="rect" coords="0,56,429,80"/>
<area href="classcds_1_1memory_1_1michael_1_1page__cached__allocator.html" title="Page cacheable heap." alt="cds::memory::michael::page_cached_allocator&lt; FreeListCapacity, Heap &gt;" shape="rect" coords="0,112,429,136"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap_1_1active__tag.html">active_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processor heap's <code>active</code> field.  <a href="classcds_1_1memory_1_1michael_1_1_heap_1_1active__tag.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcds_1_1memory_1_1michael_1_1_heap_1_1anchor__tag.html">anchor_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Anchor of the superblock descriptor. Updated by CAS.  <a href="structcds_1_1memory_1_1michael_1_1_heap_1_1anchor__tag.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap_1_1block__header.html">block_header</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocated block header.  <a href="classcds_1_1memory_1_1michael_1_1_heap_1_1block__header.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcds_1_1memory_1_1michael_1_1_heap_1_1processor__desc.html">processor_desc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processor descriptor.  <a href="structcds_1_1memory_1_1michael_1_1_heap_1_1processor__desc.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcds_1_1memory_1_1michael_1_1_heap_1_1processor__heap__base.html">processor_heap_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processor heap.  <a href="structcds_1_1memory_1_1michael_1_1_heap_1_1processor__heap__base.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcds_1_1memory_1_1michael_1_1_heap_1_1superblock__desc.html">superblock_desc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Superblock descriptor.  <a href="structcds_1_1memory_1_1michael_1_1_heap_1_1superblock__desc.html#details">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a6a0beaa35451ba2bad793c48bdaa056b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#a6a0beaa35451ba2bad793c48bdaa056b">superblock_state</a> { <a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#a6a0beaa35451ba2bad793c48bdaa056ba75de5e2001a86104f9e65fbd2d5141b1">SBSTATE_ACTIVE</a> =  0, 
<a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#a6a0beaa35451ba2bad793c48bdaa056baee281a694bde1e8d634ac3280174fe21">SBSTATE_FULL</a> =  1, 
<a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#a6a0beaa35451ba2bad793c48bdaa056ba5d3216c72f26b615273d1fa5127288a2">SBSTATE_PARTIAL</a> =  2, 
<a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#a6a0beaa35451ba2bad793c48bdaa056bab4a536d68e89761385b76a841a812a27">SBSTATE_EMPTY</a> =  3
 }</td></tr>
<tr class="memdesc:a6a0beaa35451ba2bad793c48bdaa056b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Superblock states.  <a href="classcds_1_1memory_1_1michael_1_1_heap.html#a6a0beaa35451ba2bad793c48bdaa056b">More...</a><br/></td></tr>
<tr class="memitem:abe2b36162336f20bc4b0b6e253e39f89"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe2b36162336f20bc4b0b6e253e39f89"></a>
typedef options::sys_topology&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#abe2b36162336f20bc4b0b6e253e39f89">sys_topology</a></td></tr>
<tr class="memdesc:abe2b36162336f20bc4b0b6e253e39f89"><td class="mdescLeft">&#160;</td><td class="mdescRight">effective system topology <br/></td></tr>
<tr class="memitem:abef9595b75b00322d9163cadf5aebe06"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abef9595b75b00322d9163cadf5aebe06"></a>
typedef options::system_heap&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#abef9595b75b00322d9163cadf5aebe06">system_heap</a></td></tr>
<tr class="memdesc:abef9595b75b00322d9163cadf5aebe06"><td class="mdescLeft">&#160;</td><td class="mdescRight">effective system heap <br/></td></tr>
<tr class="memitem:a64501ffd0f7bc7833b1f1ef3e626e300"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a64501ffd0f7bc7833b1f1ef3e626e300"></a>
typedef options::aligned_heap&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#a64501ffd0f7bc7833b1f1ef3e626e300">aligned_heap</a></td></tr>
<tr class="memdesc:a64501ffd0f7bc7833b1f1ef3e626e300"><td class="mdescLeft">&#160;</td><td class="mdescRight">effective aligned heap <br/></td></tr>
<tr class="memitem:a996183c3e9b5499494e5e68d24b29ae6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a996183c3e9b5499494e5e68d24b29ae6"></a>
typedef options::sizeclass_selector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#a996183c3e9b5499494e5e68d24b29ae6">sizeclass_selector</a></td></tr>
<tr class="memdesc:a996183c3e9b5499494e5e68d24b29ae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">effective sizeclass selector <br/></td></tr>
<tr class="memitem:a85ee21c40ea51ef02622b2eb37349647"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a85ee21c40ea51ef02622b2eb37349647"></a>
typedef options::page_heap&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#a85ee21c40ea51ef02622b2eb37349647">page_heap</a></td></tr>
<tr class="memdesc:a85ee21c40ea51ef02622b2eb37349647"><td class="mdescLeft">&#160;</td><td class="mdescRight">effective page heap <br/></td></tr>
<tr class="memitem:aa35c2391d7050ceab8dd393771130d10"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa35c2391d7050ceab8dd393771130d10"></a>
typedef options::procheap_stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#aa35c2391d7050ceab8dd393771130d10">procheap_stat</a></td></tr>
<tr class="memdesc:aa35c2391d7050ceab8dd393771130d10"><td class="mdescLeft">&#160;</td><td class="mdescRight">effective processor heap statistics <br/></td></tr>
<tr class="memitem:a0a8cdef4d2735ec878517211b38f468c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a8cdef4d2735ec878517211b38f468c"></a>
typedef options::os_allocated_stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#a0a8cdef4d2735ec878517211b38f468c">os_allocated_stat</a></td></tr>
<tr class="memdesc:a0a8cdef4d2735ec878517211b38f468c"><td class="mdescLeft">&#160;</td><td class="mdescRight">effective OS-allocated memory statistics <br/></td></tr>
<tr class="memitem:ac1b3e55db05e89b7fb97bddb02b2c026"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac1b3e55db05e89b7fb97bddb02b2c026"></a>
typedef <br class="typebreak"/>
details::bound_checker_selector<br class="typebreak"/>
&lt; typename <br class="typebreak"/>
options::check_bounds &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#ac1b3e55db05e89b7fb97bddb02b2c026">bound_checker</a></td></tr>
<tr class="memdesc:ac1b3e55db05e89b7fb97bddb02b2c026"><td class="mdescLeft">&#160;</td><td class="mdescRight">effective bound checker <br/></td></tr>
<tr class="memitem:af3bd62a1f7a80d128184270fb01ad7f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3bd62a1f7a80d128184270fb01ad7f2"></a>
typedef <br class="typebreak"/>
<a class="el" href="classcds_1_1details_1_1type__padding.html">cds::details::type_padding</a><br class="typebreak"/>
&lt; <a class="el" href="structcds_1_1memory_1_1michael_1_1_heap_1_1processor__heap__base.html">processor_heap_base</a>, <br class="typebreak"/>
c_nAlignment &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#af3bd62a1f7a80d128184270fb01ad7f2">processor_heap</a></td></tr>
<tr class="memdesc:af3bd62a1f7a80d128184270fb01ad7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned superblock descriptor. <br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afa39c2de9b9da0e18e87436f2613bd65"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa39c2de9b9da0e18e87436f2613bd65"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#afa39c2de9b9da0e18e87436f2613bd65">Heap</a> ()</td></tr>
<tr class="memdesc:afa39c2de9b9da0e18e87436f2613bd65"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html" title="Michael&#39;s allocator.">Heap</a> constructor. <br/></td></tr>
<tr class="memitem:a252214ab55281e3bfe1e0fc8447f37cf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#a252214ab55281e3bfe1e0fc8447f37cf">~Heap</a> ()</td></tr>
<tr class="memdesc:a252214ab55281e3bfe1e0fc8447f37cf"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html" title="Michael&#39;s allocator.">Heap</a> destructor.  <a href="#a252214ab55281e3bfe1e0fc8447f37cf"></a><br/></td></tr>
<tr class="memitem:a792f32cbddd5a047f7cfc7c9cea40eac"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#a792f32cbddd5a047f7cfc7c9cea40eac">alloc</a> (size_t nSize)</td></tr>
<tr class="memdesc:a792f32cbddd5a047f7cfc7c9cea40eac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory block.  <a href="#a792f32cbddd5a047f7cfc7c9cea40eac"></a><br/></td></tr>
<tr class="memitem:a343fc7dbff7d41806cd137346d35c67e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#a343fc7dbff7d41806cd137346d35c67e">free</a> (void *pMemory)</td></tr>
<tr class="memdesc:a343fc7dbff7d41806cd137346d35c67e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free previously allocated memory block.  <a href="#a343fc7dbff7d41806cd137346d35c67e"></a><br/></td></tr>
<tr class="memitem:ad8cc511aa052e261f26de80b4bbf6ca3"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#ad8cc511aa052e261f26de80b4bbf6ca3">realloc</a> (void *pMemory, size_t nNewSize)</td></tr>
<tr class="memdesc:ad8cc511aa052e261f26de80b4bbf6ca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocate memory block.  <a href="#ad8cc511aa052e261f26de80b4bbf6ca3"></a><br/></td></tr>
<tr class="memitem:a709a8a845c434755b31ac2a42336de37"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#a709a8a845c434755b31ac2a42336de37">alloc_aligned</a> (size_t nSize, size_t nAlignment)</td></tr>
<tr class="memdesc:a709a8a845c434755b31ac2a42336de37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate aligned memory block.  <a href="#a709a8a845c434755b31ac2a42336de37"></a><br/></td></tr>
<tr class="memitem:a680f5b48e5e7388ee17e48808a60df5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#a680f5b48e5e7388ee17e48808a60df5f">free_aligned</a> (void *pMemory)</td></tr>
<tr class="memdesc:a680f5b48e5e7388ee17e48808a60df5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free aligned memory block previously allocated by <a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#a709a8a845c434755b31ac2a42336de37">alloc_aligned</a>.  <a href="#a680f5b48e5e7388ee17e48808a60df5f"></a><br/></td></tr>
<tr class="memitem:aaf90833cc619a4779a6efe58ca993600"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf90833cc619a4779a6efe58ca993600"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#aaf90833cc619a4779a6efe58ca993600">summaryStat</a> (<a class="el" href="structcds_1_1memory_1_1michael_1_1summary__stat.html">summary_stat</a> &amp;st)</td></tr>
<tr class="memdesc:aaf90833cc619a4779a6efe58ca993600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get instant summary statistics. <br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a7ec15f69cb5583d704aeed42c68983fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ec15f69cb5583d704aeed42c68983fe"></a>
static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#a7ec15f69cb5583d704aeed42c68983fe">c_nMaxBlockInSuperBlock</a> = 1024 * 2</td></tr>
<tr class="memdesc:a7ec15f69cb5583d704aeed42c68983fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Max count of blocks in superblock (2 ** 11) <br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a04b23a7a3623c77ad0a2ab9213620ca2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04b23a7a3623c77ad0a2ab9213620ca2"></a>
<a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#abe2b36162336f20bc4b0b6e253e39f89">sys_topology</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#a04b23a7a3623c77ad0a2ab9213620ca2">m_Topology</a></td></tr>
<tr class="memdesc:a04b23a7a3623c77ad0a2ab9213620ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">System topology. <br/></td></tr>
<tr class="memitem:aa2e6b8061282c15e60bf470232e3fba2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2e6b8061282c15e60bf470232e3fba2"></a>
<a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#abef9595b75b00322d9163cadf5aebe06">system_heap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#aa2e6b8061282c15e60bf470232e3fba2">m_LargeHeap</a></td></tr>
<tr class="memdesc:aa2e6b8061282c15e60bf470232e3fba2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html" title="Michael&#39;s allocator.">Heap</a> for large block. <br/></td></tr>
<tr class="memitem:aa3d42d2791fba22c8c0410ddc650abed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa3d42d2791fba22c8c0410ddc650abed"></a>
<a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#a64501ffd0f7bc7833b1f1ef3e626e300">aligned_heap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#aa3d42d2791fba22c8c0410ddc650abed">m_AlignedHeap</a></td></tr>
<tr class="memdesc:aa3d42d2791fba22c8c0410ddc650abed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal aligned heap. <br/></td></tr>
<tr class="memitem:ab3fb6edbbc87ae18a562f9f16e0e1163"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab3fb6edbbc87ae18a562f9f16e0e1163"></a>
<a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#a996183c3e9b5499494e5e68d24b29ae6">sizeclass_selector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#ab3fb6edbbc87ae18a562f9f16e0e1163">m_SizeClassSelector</a></td></tr>
<tr class="memdesc:ab3fb6edbbc87ae18a562f9f16e0e1163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size-class selector. <br/></td></tr>
<tr class="memitem:a6bcb1f3233ba94d768c1066f27ee644c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6bcb1f3233ba94d768c1066f27ee644c"></a>
std::atomic&lt; <a class="el" href="structcds_1_1memory_1_1michael_1_1_heap_1_1processor__desc.html">processor_desc</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#a6bcb1f3233ba94d768c1066f27ee644c">m_arrProcDesc</a></td></tr>
<tr class="memdesc:a6bcb1f3233ba94d768c1066f27ee644c"><td class="mdescLeft">&#160;</td><td class="mdescRight">array of pointers to the processor descriptors <br/></td></tr>
<tr class="memitem:a9aae52de1754cd066fd6745af0a74c2b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9aae52de1754cd066fd6745af0a74c2b"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#a9aae52de1754cd066fd6745af0a74c2b">m_nProcessorCount</a></td></tr>
<tr class="memdesc:a9aae52de1754cd066fd6745af0a74c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processor count. <br/></td></tr>
<tr class="memitem:ae11cc64382eafdea5615bf34fe00eddd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae11cc64382eafdea5615bf34fe00eddd"></a>
<a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#ac1b3e55db05e89b7fb97bddb02b2c026">bound_checker</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#ae11cc64382eafdea5615bf34fe00eddd">m_BoundChecker</a></td></tr>
<tr class="memdesc:ae11cc64382eafdea5615bf34fe00eddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bound checker. <br/></td></tr>
<tr class="memitem:a24a5571740e0dbaeeaecf2009ec6bdfb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24a5571740e0dbaeeaecf2009ec6bdfb"></a>
<a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#a0a8cdef4d2735ec878517211b38f468c">os_allocated_stat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#a24a5571740e0dbaeeaecf2009ec6bdfb">m_OSAllocStat</a></td></tr>
<tr class="memdesc:a24a5571740e0dbaeeaecf2009ec6bdfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">OS-allocated memory statistics. <br/></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename... Options&gt;<br/>
class cds::memory::michael::Heap&lt; Options &gt;</h3>

<p>Michael's allocator. </p>
<p>This class provides base functionality for Michael's allocator. It does not provide the interface described by <code>std::allocator</code>, therefore, we name it as a heap, not as an allocator. The heap interface is closer to semantics of <code>malloc</code> / <code>free</code> system functions. The heap supports allocation of aligned and unaligned data.</p>
<p>The algorithm is based on simplified version of </p>
<ul>
<li>[2004] M.Michael "Scalable Lock-free Dynamic Memory Allocation"</li>
</ul>
<p>that, in turn, is concurrent version of well-known Hoard allocator developed by Emery Berger, see </p>
<ul>
<li>[2002] Emery Berger "Memory Management for High-Performance Application", PhD thesis</li>
</ul>
<p>This is powerful, scalable, fully customizable heap with fast-path without any locks that has been developed specifically for multi-threading. With opt:sys_topology you can set as many allocation arena ("processor heap") as you need. You can manually bound any your thread to any arena ("processor"). With <a class="el" href="structcds_1_1memory_1_1michael_1_1opt_1_1sizeclass__selector.html" title="Option setter specifies size-class selector.">opt::sizeclass_selector</a> option you can manage allocation granularity. With <a class="el" href="structcds_1_1memory_1_1michael_1_1opt_1_1page__heap.html" title="Option setter specifies page heap.">opt::page_heap</a> you can utilize any OS-provided features for page allocation like <code>mmap</code>, <code>VirtualAlloc</code> etc. The heap can gather internal statistics that helps you to tune your application. The <a class="el" href="structcds_1_1memory_1_1michael_1_1opt_1_1check__bounds.html" title="Option setter for bounds checking.">opt::check_bounds</a> feature can help you to find a memory buffer overflow.</p>
<p>Brief algorithm description from Michael's work:</p>
<p>Large blocks (greater than 64K) are allocated directly from the <a class="el" href="namespacecds_1_1_o_s.html" title="OS specific wrappers.">OS</a> and freed directly to the <a class="el" href="namespacecds_1_1_o_s.html" title="OS specific wrappers.">OS</a>. For smaller block sizes, the heap is composed of large superblocks (64 KB or 1MB size). Each superblock is divided into multiple equal-sized blocks. Superblocks are distributed among size classes based on their block sizes. Each size class contains multiple processor heaps proportional to the number of processors in the system. A processor heap contains at most one active superblock. An active superblock contains one or more blocks available for reservation that are guaranteed to be available to threads that reach them through the header of the processor heap. Each superblock is associated with a descriptor. Each allocated block contains a prefix (8 bytes) that points to the descriptor of its superblock. On the first call to malloc, the static structures for the size classes and processor heaps (about 16 KB for a 16 processor machine) are allocated and initialized in a lock-free manner.</p>
<p>Malloc starts by identifying the appropriate processor heap, based on the requested block size and the identity of the calling thread. Typically, the heap already has an active superblock with blocks available for reservation. The thread atomically reads a pointer to the descriptor of the active superblock and reserves a block. Next, the thread atomically pops a block from that superblock and updates its descriptor. A typical free pushes the freed block into the list of available blocks of its original superblock by atomically updating its descriptor.</p>
<p><b>Constraint</b>: one superblock may contain up to 2048 block. This restriction imposes a restriction on the maximum superblock size.</p>
<p>Available <code>Options:</code> </p>
<ul>
<li><a class="el" href="structcds_1_1memory_1_1michael_1_1opt_1_1sys__topology.html">opt::sys_topology</a> - class that describes system topology needed for allocator. Default is <code>cds::OS::topology</code> (see <a class="el" href="structcds_1_1_o_s_1_1_win32_1_1topology.html" title="System topology.">cds::OS::Win32::topology</a> for interface description)</li>
<li><a class="el" href="structcds_1_1memory_1_1michael_1_1opt_1_1system__heap.html">opt::system_heap</a> - option setter for an allocator for large blocks that is used for direct allocation from <a class="el" href="namespacecds_1_1_o_s.html" title="OS specific wrappers.">OS</a>. Default is <a class="el" href="structcds_1_1memory_1_1michael_1_1malloc__heap.html">malloc_heap</a>.</li>
<li><a class="el" href="structcds_1_1memory_1_1michael_1_1opt_1_1aligned__heap.html">opt::aligned_heap</a> - option setter for a heap used for internal aligned memory management. Default is <a class="el" href="structcds_1_1memory_1_1michael_1_1aligned__malloc__heap.html">aligned_malloc_heap</a></li>
<li><a class="el" href="structcds_1_1memory_1_1michael_1_1opt_1_1page__heap.html">opt::page_heap</a> - option setter for a heap used for page (superblock) allocation of 64K/1M size. Default is <a class="el" href="classcds_1_1memory_1_1michael_1_1page__cached__allocator.html">page_cached_allocator</a></li>
<li><a class="el" href="structcds_1_1memory_1_1michael_1_1opt_1_1sizeclass__selector.html">opt::sizeclass_selector</a> - option setter for a class used to select appropriate size-class for incoming allocation request. Default is <a class="el" href="classcds_1_1memory_1_1michael_1_1default__sizeclass__selector.html">default_sizeclass_selector</a></li>
<li><a class="el" href="structcds_1_1memory_1_1michael_1_1opt_1_1free__list.html">opt::free_list</a> - option setter for a class to manage a list of free superblock descriptors Default is <a class="el" href="classcds_1_1memory_1_1michael_1_1free__list__locked.html">free_list_locked</a></li>
<li><a class="el" href="structcds_1_1memory_1_1michael_1_1opt_1_1partial__list.html">opt::partial_list</a> - option setter for a class to manage a list of partial filled superblocks Default is <a class="el" href="classcds_1_1memory_1_1michael_1_1partial__list__locked.html">partial_list_locked</a></li>
<li><a class="el" href="structcds_1_1memory_1_1michael_1_1opt_1_1procheap__stat.html">opt::procheap_stat</a> - option setter for a class to gather internal statistics for memory allocation that is maintained by the heap. Default is <a class="el" href="classcds_1_1memory_1_1michael_1_1procheap__empty__stat.html">procheap_empty_stat</a></li>
<li><a class="el" href="structcds_1_1memory_1_1michael_1_1opt_1_1os__allocated__stat.html">opt::os_allocated_stat</a> - option setter for a class to gather internal statistics for large block allocation. Term "large block" is specified by the size-class selector (see <a class="el" href="structcds_1_1memory_1_1michael_1_1opt_1_1sizeclass__selector.html">opt::sizeclass_selector</a>) and it is 64K for <a class="el" href="classcds_1_1memory_1_1michael_1_1default__sizeclass__selector.html">default_sizeclass_selector</a>. Any block that is large that 64K is allocated from <a class="el" href="namespacecds_1_1_o_s.html" title="OS specific wrappers.">OS</a> directly. <code>os_allocated_stat</code> option is set a class to gather statistics for large blocks. Default is <a class="el" href="structcds_1_1memory_1_1michael_1_1os__allocated__empty.html">os_allocated_empty</a></li>
<li><a class="el" href="structcds_1_1memory_1_1michael_1_1opt_1_1check__bounds.html">opt::check_bounds</a> - a bound checker. Default is no bound checker (<a class="el" href="structcds_1_1opt_1_1none.html" title="Type indicates that an option is not specified and the default one should be used.">cds::opt::none</a>)</li>
</ul>
<dl class="section user"><dt>Usage:</dt><dd>The heap is the basic building block for your allocator or <code> operator new</code> implementation.</dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/memory/michael/allocator.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Heap with explicitly defined options:</span></div>
<div class="line"><a class="code" href="classcds_1_1memory_1_1michael_1_1_heap.html" title="Michael&#39;s allocator.">cds::memory::michael::Heap</a>&lt;</div>
<div class="line">    opt::aligned_heap&lt; aligned_malloc_heap &gt;,</div>
<div class="line">    opt::page_heap&lt; page_cached_allocator&lt;16, malloc_heap&gt; &gt;</div>
<div class="line">&gt;   myHeap  ;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Heap with default options:</span></div>
<div class="line"><a class="code" href="classcds_1_1memory_1_1michael_1_1_heap.html" title="Michael&#39;s allocator.">cds::memory::michael::Heap&lt;&gt;</a>    myDefHeap   ;</div>
</div><!-- fragment --><dl class="section user"><dt>How to make std-like allocator</dt><dd></dd></dl>
<p>There are serious differencies of heap and <code>std::allocator</code> interface:</p>
<ul>
<li><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html" title="Michael&#39;s allocator.">Heap</a> is stateful, and <code>std::allocator</code> is stateless.</li>
<li><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html" title="Michael&#39;s allocator.">Heap</a> has much more template parameters than <code>std::allocator</code> </li>
<li><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html" title="Michael&#39;s allocator.">Heap</a> has low-level interface for memory allocating only unlike the allocator interface that can construct/destroy objects of any type T.</li>
</ul>
<p>To convert heap interface into <code>std::allocator</code> -like interface you should:</p>
<ul>
<li>Declare object of class <a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html" title="Michael&#39;s allocator.">cds::memory::michael::Heap</a> specifying the necessary template parameters; this is usually static object</li>
<li>Create a class with <code>std::allocator</code> interface that uses the function of heap. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/memory/michael/allocator.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div>
<div class="line"><span class="keyword">class </span>MichaelAllocator</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">typedef</span> std::allocator&lt;T&gt;               std_allocator   ;</div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="classcds_1_1memory_1_1michael_1_1_heap.html" title="Michael&#39;s allocator.">cds::memory::michael::Heap&lt;&gt;</a>    michael_heap    ;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Michael heap static object</span></div>
<div class="line">    <span class="keyword">static</span> michael_heap     s_Heap  ;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Declare typedefs from std::allocator</span></div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> std_allocator::const_pointer   const_pointer   ;</div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> std_allocator::pointer         pointer         ;</div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> std_allocator::const_reference const_reference ;</div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> std_allocator::reference       reference       ;</div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> std_allocator::difference_type difference_type ;</div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> std_allocator::size_type       size_type       ;</div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> std_allocator::value_type      value_type      ;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Allocation function</span></div>
<div class="line">    pointer allocate( size_type _Count, <span class="keyword">const</span> <span class="keywordtype">void</span>* _Hint )</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span>pointer<span class="keyword">&gt;</span>( s_Heap.alloc( <span class="keyword">sizeof</span>(T) * _Count )) ;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Deallocation function</span></div>
<div class="line">    <span class="keywordtype">void</span> deallocate( pointer _Ptr, size_type _Count )</div>
<div class="line">    {</div>
<div class="line">        s_Heap.<a class="code" href="classcds_1_1memory_1_1michael_1_1_heap.html#a343fc7dbff7d41806cd137346d35c67e" title="Free previously allocated memory block.">free</a>( _Ptr ) ;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Other std::allocator specific functions: address, construct, destroy, etc.</span></div>
<div class="line">    ...</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Rebinding allocator to other type</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> _Other&gt;</div>
<div class="line">    <span class="keyword">struct </span>rebind {</div>
<div class="line">        <span class="keyword">typedef</span> MichaelAllocator&lt;_Other&gt; <a class="code" href="class_alloc_1_1template_01rebind_1_1other.html">other</a>;</div>
<div class="line">    };</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// In .cpp file:</span></div>
<div class="line">MichaelAllocator::michael_heap MichaelAllocator::s_Heap ;</div>
</div><!-- fragment --> </li>
</ul>
</div><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a6a0beaa35451ba2bad793c48bdaa056b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Options&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#a6a0beaa35451ba2bad793c48bdaa056b">cds::memory::michael::Heap::superblock_state</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Superblock states. </p>
<p>A superblock can be in one of four states: <code>ACTIVE</code>, <code>FULL</code>, <code>PARTIAL</code>, or <code>EMPTY</code>. A superblock is <code>ACTIVE</code> if it is the active superblock in a heap, or if a thread intends to try to install it as such. A superblock is <code>FULL</code> if all its blocks are either allocated or reserved. A superblock is <code>PARTIAL</code> if it is not <code>ACTIVE</code> and contains unreserved available blocks. A superblock is <code>EMPTY</code> if all its blocks are free and it is not <code>ACTIVE</code>. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a6a0beaa35451ba2bad793c48bdaa056ba75de5e2001a86104f9e65fbd2d5141b1"></a>SBSTATE_ACTIVE</em>&nbsp;</td><td>
<p>superblock is active </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a6a0beaa35451ba2bad793c48bdaa056baee281a694bde1e8d634ac3280174fe21"></a>SBSTATE_FULL</em>&nbsp;</td><td>
<p>superblock is full </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a6a0beaa35451ba2bad793c48bdaa056ba5d3216c72f26b615273d1fa5127288a2"></a>SBSTATE_PARTIAL</em>&nbsp;</td><td>
<p>superblock is partially allocated </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a6a0beaa35451ba2bad793c48bdaa056bab4a536d68e89761385b76a841a812a27"></a>SBSTATE_EMPTY</em>&nbsp;</td><td>
<p>superblock is empty and may be freed </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a252214ab55281e3bfe1e0fc8447f37cf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html">cds::memory::michael::Heap</a>&lt; Options &gt;::~<a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html">Heap</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html" title="Michael&#39;s allocator.">Heap</a> destructor. </p>
<p>The destructor frees all memory allocated by the heap. </p>

</div>
</div>
<h2>Member Function Documentation</h2>
<a class="anchor" id="a792f32cbddd5a047f7cfc7c9cea40eac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html">cds::memory::michael::Heap</a>&lt; Options &gt;::alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate memory block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nSize</td><td>Size of memory block to allocate in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a709a8a845c434755b31ac2a42336de37"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html">cds::memory::michael::Heap</a>&lt; Options &gt;::alloc_aligned </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nAlignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate aligned memory block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nSize</td><td>Size of memory block to allocate in bytes </td></tr>
    <tr><td class="paramname">nAlignment</td><td>Alignment </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a343fc7dbff7d41806cd137346d35c67e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html">cds::memory::michael::Heap</a>&lt; Options &gt;::free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pMemory</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free previously allocated memory block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMemory</td><td>Pointer to memory block to free </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classcds_1_1memory_1_1michael_1_1page__cached__allocator.html#a6137758a0675738c54e9660b7027f5ba">cds::memory::michael::page_cached_allocator&lt; FreeListCapacity, Heap &gt;</a>, and <a class="el" href="classcds_1_1memory_1_1michael_1_1page__allocator.html#a81e438d7e06f9987bbdd54311979ca7b">cds::memory::michael::page_allocator&lt; Heap &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a680f5b48e5e7388ee17e48808a60df5f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html">cds::memory::michael::Heap</a>&lt; Options &gt;::free_aligned </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pMemory</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free aligned memory block previously allocated by <a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#a709a8a845c434755b31ac2a42336de37">alloc_aligned</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMemory</td><td>Pointer to memory block to free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad8cc511aa052e261f26de80b4bbf6ca3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html">cds::memory::michael::Heap</a>&lt; Options &gt;::realloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pMemory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nNewSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reallocate memory block. </p>
<p>If <code>nNewSize</code> is zero, then the block pointed to by <code>pMemory</code> is freed; the return value is <code>NULL</code>, and <code>pMemory</code> is left pointing at a freed block.</p>
<p>If there is not enough available memory to expand the block to the given size, the original block is left unchanged, and <code>NULL</code> is returned.</p>
<p>Aligned memory block cannot be realloc'ed: if <code>pMemory</code> has been allocated by <a class="el" href="classcds_1_1memory_1_1michael_1_1_heap.html#a709a8a845c434755b31ac2a42336de37">alloc_aligned</a>, then the return value is <code>NULL</code> and the original block is left unchanged. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMemory</td><td>Pointer to previously allocated memory block </td></tr>
    <tr><td class="paramname">nNewSize</td><td>New size of memory block, in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cds/memory/michael/allocator.h</li>
</ul>
</div><!-- contents -->
		<hr/>
		<div align="right">
			<b>cds</b> <b>1.2.0</b> 
			Developed by <i>Maxim Khiszinsky aka khizmax</i> 2007 - 2012
			<br/>
			<i>Autogenerated Mon Aug 20 2012 22:32:42 by Doxygen 1.8.1.2</i>
		</div>
	</BODY>
</HTML>
